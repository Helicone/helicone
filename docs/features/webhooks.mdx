---
title: "Webhooks: Real-Time LLM Integration & Automation"
sidebarTitle: "Quick start"
description: "Leverage Helicone's powerful webhook system to automate your LLM workflows. Instantly react to events, trigger actions, and integrate with external tools for enhanced AI observability and management. Perfect for developers building robust LLM applications."
twitter:title: "Helicone Webhooks: Real-Time LLM Integration & Automation"
---

<Note>
  **March 2025 Update**: We've enhanced our webhook implementation to provide a
  unified `request_response_url` field that contains both request and response
  data in a single object. This improves performance and simplifies data
  retrieval. [Learn more](#working-with-the-combined-requestresponse-url).
</Note>

## Top use cases

- **Scoring**: [Score requests based on custom logic](/features/advanced-usage/scores).
- **Data ETL**: Moving data from one system to another.
- **Automations** / Alerts: Trigger actions automatically, such as sending a Slack notification or triggering a webhook to an external tool.

## Setting up webhooks

Head over to the [webhooks page](https://us.helicone.ai/webhooks) to set up a webhook.

<Frame caption="Webhooks page">
  <img src="/images/webhooks/ngrok-example.png" alt="Ngrok example" />
</Frame>

Add the webhook URL and select the events you want to trigger on.

You will want to copy the HMAC key and add it to your webhook environment to validate the signature of the webhook request.

## Configure your webhook route

<Note>
  We recommend for startups to use [Cloudflare
  workers](https://developers.cloudflare.com/workers/) or [Vercel edge
  functions](https://vercel.com/docs/functions/edge-functions) for webhooks,
  they are simple to setup and scale very well.

We have a prebuilt [Cloudflare worker](https://deploy.workers.cloudflare.com/?url=https://github.com/Helicone/helicone/tree/main/examples/worker-helicone-scores) that you can use as a starting point.

</Note>

The webhook endpoint is a POST route that accepts the following JSON body:

### POST /webhook

The body of the request will contain the following fields:

- `request_id`: The request ID of the request that triggered the webhook.
- `request_body`: The body of the request that triggered the webhook.
- `response_body`: The body of the response that triggered the webhook.
- `request_response_url`: The URL to fetch the full request and response data.

### Example - NextJS

```tsx
import crypto from "crypto";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { request_id, request_body, response_body, request_response_url } =
    req.body;

  // STEP 1: Validate the signature of the webhook request
  const hmac = crypto.createHmac("sha256", process.env.HELICONE_WEBHOOK_SECRET);
  hmac.update(JSON.stringify(req.body)); // Use the entire body for validation
  const signature = hmac.digest("hex");
  if (signature !== req.headers["helicone-signature"]) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // STEP 2: Do something with the webhook data
  console.log(request_id, request_body, response_body);

  // STEP 3: Optionally fetch the full request/response data if needed
  if (request_response_url) {
    try {
      const response = await fetch(request_response_url);
      const fullData = await response.json();
      console.log("Full request/response data:", fullData);
      // Process the complete data...
    } catch (error) {
      console.error("Error fetching full data:", error);
    }
  }

  return res.status(200).json({ message: "Webhook received" });
}
```

## Webhook Configuration

When setting up a webhook, you can configure the following options:

1. **Destination URL**: The URL where webhook payloads will be sent.
2. **Sample Rate**: Control what percentage of requests trigger webhooks (0-100%).
3. **Property Filters**: Only send webhooks for requests with specific properties.
4. **Include Data**: Toggle whether to include additional data like costs and S3 links (enabled by default).

### Standard Webhook Payload

By default, webhooks send a minimal payload with just the request ID and truncated request/response bodies:

```json
{
  "request_id": "uuid-string",
  "request_body": "request-body-string",
  "response_body": "response-body-string"
}
```

### Enhanced Webhook Payload

When the `includeData` option is enabled, webhooks include additional useful information:

```json
{
  "request_id": "uuid-string",
  "request_body": "request-body-string",
  "response_body": "response-body-string",
  "request_body_url": "https://s3-url-to-full-request-body",
  "response_body_url": "https://s3-url-to-full-response-body",
  "model": "gpt-4",
  "provider": "openai",
  "metadata": {
    "cost": 0.0123,
    "promptTokens": 150,
    "completionTokens": 50,
    "totalTokens": 200,
    "latencyMs": 1200
  }
}
```

The enhanced payload provides:

- **S3 URLs**: Direct links to the full request and response bodies
- **Model Information**: The model and provider used
- **Cost Data**: Calculated cost based on token usage
- **Token Counts**: Prompt, completion, and total token counts
- **Latency**: Request-to-response time in milliseconds

This additional data makes it easier to track costs and analyze performance without making additional API calls.

## Working with the Combined Request/Response URL

The `request_response_url` field provides a pre-signed S3 URL that contains both the complete request and response data in a single JSON object. This approach offers several advantages:

1. **Complete Data Access**: Get the full, untruncated request and response data, including all fields and metadata.
2. **Single Request**: Retrieve both request and response with a single HTTP call.
3. **Structured Format**: The data is returned in a structured JSON format that's easy to parse and process.

### Example: Fetching and Processing the Combined Data

Here's how to fetch and process the data from the `request_response_url`:

```javascript
async function processWebhook(webhookData) {
  // Extract the combined URL from the webhook payload
  const { request_response_url } = webhookData;

  if (request_response_url) {
    try {
      // Fetch the combined data
      const response = await fetch(request_response_url);
      const combinedData = await response.json();

      // Now you have access to both request and response data
      const { request, response: llmResponse } = combinedData;

      // Process the request data
      console.log("Request model:", request.model);
      console.log("User message:", request.messages[0].content);

      // Process the response data
      console.log("Response content:", llmResponse.choices[0].message.content);
      console.log("Token usage:", llmResponse.usage.total_tokens);

      // Perform your custom logic here
      // ...
    } catch (error) {
      console.error("Error fetching combined data:", error);
    }
  }
}
```

### Common Use Cases

The combined request/response data is particularly useful for:

1. **Advanced Analytics**: Analyze the full request and response to extract insights about your LLM usage.
2. **Cost Tracking**: Access detailed token usage information to track costs across different models and requests.
3. **Quality Monitoring**: Evaluate the quality of responses based on the complete context of the request.
4. **Data Archiving**: Store the complete interaction data for compliance or historical analysis.

## Webhook Security

## Troubleshooting Webhooks

### Common Issues

1. **Missing or Invalid Signature**

   - Ensure you're using the correct HMAC key provided in the Helicone dashboard.
   - Verify that you're calculating the signature using the entire request body.

2. **URL Expiration**

   - The `request_response_url` is a pre-signed URL that expires after 30 minutes. Make sure to fetch the data promptly after receiving the webhook.

3. **Large Payloads**

   - Remember that request and response bodies in the webhook payload are truncated if they exceed 10KB. Always use the `request_response_url` for complete data.

4. **Webhook Timeouts**
   - Webhook delivery will time out after 2 minutes. Ensure your endpoint responds quickly, and consider using a queue for processing long-running tasks.

### Debugging Tips

1. **Local Testing**

   - Use tools like [ngrok](https://ngrok.com/) or [Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/) to expose your local development server for webhook testing.

2. **Logging**

   - Implement comprehensive logging in your webhook handler to track received payloads and any processing errors.

3. **Retry Logic**

   - Consider implementing retry logic in your webhook consumer to handle temporary failures when fetching the `request_response_url` data.

4. **Webhook Monitoring**
   - Monitor webhook deliveries in the Helicone dashboard to identify any patterns of failures or issues.
