/**
 * Turn serialized HTML into a hast tree.
 *
 * @param {VFileCompatible} value
 *   Serialized HTML to parse.
 * @param {Options | null | undefined} [options={}]
 *   Configuration (optional).
 * @returns {Root}
 *   Tree.
 */
export function fromHtml(
  value: VFileCompatible,
  options?: Options | null | undefined
): Root
export type Root = import('hast').Root
export type VFileCompatible = import('vfile').VFileCompatible
export type FromParse5Options = Pick<
  import('hast-util-from-parse5').Options,
  'space' | 'verbose'
>
/**
 * Known names of parse errors.
 */
export type ErrorCode = keyof {
  abandonedHeadElementChild: {
    reason: string
    /**
     * @typedef {Pick<import('hast-util-from-parse5').Options, 'space' | 'verbose'>} FromParse5Options
     *
     * @typedef {keyof errors} ErrorCode
     *   Known names of parse errors.
     * @typedef {0 | 1 | 2 | boolean} ErrorSeverity
     *   Error severity:
     *
     *   * `0` or `false`
     *     â€” turn the parse error off
     *   * `1` or `true`
     *     â€” turn the parse error into a warning
     *   * `2`
     *     â€” turn the parse error into an actual error: processing stops.
     * @typedef {Partial<Record<ErrorCode, ErrorSeverity | null | undefined>>} ErrorFields
     *   Error configuration.
     *
     * @typedef Error
     *   Error from `parse5`.
     * @property {string} code
     * @property {number} startLine
     * @property {number} startCol
     * @property {number} startOffset
     * @property {number} endLine
     * @property {number} endCol
     * @property {number} endOffset
     *
     * @callback OnError
     *   Handle errors.
     * @param {VFileMessage} error
     *   Message.
     * @returns {void}
     *   Nothing.
     *
     * @typedef ParseFields
     * @property {boolean | null | undefined} [fragment=false]
     *   Specify whether to parse a fragment, instead of a complete document.
     *
     *   In document mode, unopened `html`, `head`, and `body` elements are opened
     *   in just the right places.
     * @property {OnError | null | undefined} [onerror]
     *   Call `onerror` with parse errors while parsing.
     *
     *   > ðŸ‘‰ **Note**: parse errors are currently being added to HTML.
     *   > Not all errors emitted by parse5 (or us) are specced yet.
     *   > Some documentation may still be missing.
     *
     *   Specific rules can be turned off by setting them to `false` (or `0`).
     *   The default, when `emitParseErrors: true`, is `true` (or `1`), and means
     *   that rules emit as warnings.
     *   Rules can also be configured with `2`, to turn them into fatal errors.
     *
     * @typedef {FromParse5Options & ParseFields & ErrorFields} Options
     *   Configuration.
     */
    description: string
    url: boolean
  }
  abruptClosingOfEmptyComment: {
    reason: string
    description: string
  }
  abruptDoctypePublicIdentifier: {
    reason: string
    description: string
  }
  abruptDoctypeSystemIdentifier: {
    reason: string
    description: string
  }
  absenceOfDigitsInNumericCharacterReference: {
    reason: string
    description: string
  }
  cdataInHtmlContent: {
    reason: string
    description: string
  }
  characterReferenceOutsideUnicodeRange: {
    reason: string
    description: string
  }
  closingOfElementWithOpenChildElements: {
    reason: string
    description: string
    url: boolean
  }
  controlCharacterInInputStream: {
    reason: string
    description: string
  }
  controlCharacterReference: {
    reason: string
    description: string
  }
  disallowedContentInNoscriptInHead: {
    reason: string
    description: string
    url: boolean
  }
  duplicateAttribute: {
    reason: string
    description: string
  }
  endTagWithAttributes: {
    reason: string
    description: string
  }
  endTagWithTrailingSolidus: {
    reason: string
    description: string
  }
  endTagWithoutMatchingOpenElement: {
    reason: string
    description: string
    url: boolean
  }
  eofBeforeTagName: {
    reason: string
    description: string
  }
  eofInCdata: {
    reason: string
    description: string
  }
  eofInComment: {
    reason: string
    description: string
  }
  eofInDoctype: {
    reason: string
    description: string
  }
  eofInElementThatCanContainOnlyText: {
    reason: string
    description: string
    url: boolean
  }
  eofInScriptHtmlCommentLikeText: {
    reason: string
    description: string
  }
  eofInTag: {
    reason: string
    description: string
  }
  incorrectlyClosedComment: {
    reason: string
    description: string
  }
  incorrectlyOpenedComment: {
    reason: string
    description: string
  }
  invalidCharacterSequenceAfterDoctypeName: {
    reason: string
    description: string
  }
  invalidFirstCharacterOfTagName: {
    reason: string
    description: string
  }
  misplacedDoctype: {
    reason: string
    description: string
    url: boolean
  }
  misplacedStartTagForHeadElement: {
    reason: string
    description: string
    url: boolean
  }
  missingAttributeValue: {
    reason: string
    description: string
  }
  missingDoctype: {
    reason: string
    description: string
    url: boolean
  }
  missingDoctypeName: {
    reason: string
    description: string
  }
  missingDoctypePublicIdentifier: {
    reason: string
    description: string
  }
  missingDoctypeSystemIdentifier: {
    reason: string
    description: string
  }
  missingEndTagName: {
    reason: string
    description: string
  }
  missingQuoteBeforeDoctypePublicIdentifier: {
    reason: string
    description: string
  }
  missingQuoteBeforeDoctypeSystemIdentifier: {
    reason: string
    description: string
  }
  missingSemicolonAfterCharacterReference: {
    reason: string
    description: string
  }
  missingWhitespaceAfterDoctypePublicKeyword: {
    reason: string
    description: string
  }
  missingWhitespaceAfterDoctypeSystemKeyword: {
    reason: string
    description: string
  }
  missingWhitespaceBeforeDoctypeName: {
    reason: string
    description: string
  }
  missingWhitespaceBetweenAttributes: {
    reason: string
    description: string
  }
  missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
    reason: string
    description: string
  }
  nestedComment: {
    reason: string
    description: string
  }
  nestedNoscriptInHead: {
    reason: string
    description: string
    url: boolean
  }
  nonConformingDoctype: {
    reason: string
    description: string
    url: boolean
  }
  nonVoidHtmlElementStartTagWithTrailingSolidus: {
    reason: string
    description: string
  }
  noncharacterCharacterReference: {
    reason: string
    description: string
  }
  noncharacterInInputStream: {
    reason: string
    description: string
  }
  nullCharacterReference: {
    reason: string
    description: string
  }
  openElementsLeftAfterEof: {
    reason: string
    description: string
    url: boolean
  }
  surrogateCharacterReference: {
    reason: string
    description: string
  }
  surrogateInInputStream: {
    reason: string
    description: string
  }
  unexpectedCharacterAfterDoctypeSystemIdentifier: {
    reason: string
    description: string
  }
  unexpectedCharacterInAttributeName: {
    reason: string
    description: string
  }
  unexpectedCharacterInUnquotedAttributeValue: {
    reason: string
    description: string
  }
  unexpectedEqualsSignBeforeAttributeName: {
    reason: string
    description: string
  }
  unexpectedNullCharacter: {
    reason: string
    description: string
  }
  unexpectedQuestionMarkInsteadOfTagName: {
    reason: string
    description: string
  }
  unexpectedSolidusInTag: {
    reason: string
    description: string
  }
  unknownNamedCharacterReference: {
    reason: string
    description: string
  }
}
/**
 * Error severity:
 *
 * * `0` or `false`
 * â€” turn the parse error off
 * * `1` or `true`
 * â€” turn the parse error into a warning
 * * `2`
 * â€” turn the parse error into an actual error: processing stops.
 */
export type ErrorSeverity = 0 | 1 | 2 | boolean
/**
 * Error configuration.
 */
export type ErrorFields = Partial<
  Record<ErrorCode, ErrorSeverity | null | undefined>
>
/**
 * Error from `parse5`.
 */
export type Error = {
  code: string
  startLine: number
  startCol: number
  startOffset: number
  endLine: number
  endCol: number
  endOffset: number
}
/**
 * Handle errors.
 */
export type OnError = (error: VFileMessage) => void
export type ParseFields = {
  /**
   * Specify whether to parse a fragment, instead of a complete document.
   *
   * In document mode, unopened `html`, `head`, and `body` elements are opened
   * in just the right places.
   */
  fragment?: boolean | null | undefined
  /**
   * Call `onerror` with parse errors while parsing.
   *
   * > ðŸ‘‰ **Note**: parse errors are currently being added to HTML.
   * > Not all errors emitted by parse5 (or us) are specced yet.
   * > Some documentation may still be missing.
   *
   * Specific rules can be turned off by setting them to `false` (or `0`).
   * The default, when `emitParseErrors: true`, is `true` (or `1`), and means
   * that rules emit as warnings.
   * Rules can also be configured with `2`, to turn them into fatal errors.
   */
  onerror?: OnError | null | undefined
}
/**
 * Configuration.
 */
export type Options = FromParse5Options & ParseFields & ErrorFields
import {VFileMessage} from 'vfile-message'
