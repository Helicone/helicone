/**
 *
 * DO NOT EDIT THIS FILE UNLESS IT IS IN /costs/src/index.ts
 */

import { ModelRow } from "./interfaces/Cost";
import { allCosts, defaultProvider, providers } from "./providers/mappings";
import { COST_PRECISION_MULTIPLIER } from "./costCalc";

export function costOf({
  model,
  provider,
}: {
  model: string;
  provider: string;
}) {
  const modelLower = model?.toLowerCase();

  if (!modelLower) {
    return null;
  }

  const providerCost = providers.find((p) => {
    return (
      p.provider === provider ||
      (p.pattern && p.pattern.test(provider) ? true : false)
    );
  });

  if (!providerCost || !providerCost.costs) {
    return null;
  }

  const cost = providerCost.costs.find((cost) => {
    const valueLower = cost.model.value.toLowerCase();
    if (cost.model.operator === "equals") {
      return valueLower === modelLower;
    } else if (cost.model.operator === "startsWith") {
      return modelLower.startsWith(valueLower);
    } else if (cost.model.operator === "includes") {
      return modelLower.includes(valueLower);
    }
  });

  return cost?.cost;
}

export function costOfPrompt({
  provider,
  model,
  promptTokens,
  promptCacheWriteTokens,
  promptCacheReadTokens,
  promptAudioTokens,
  completionTokens,
  completionAudioTokens,
  images = 1,
  perCall = 1,
  multiple,
}: {
  provider: string;
  model: string;
  promptTokens: number;
  promptCacheWriteTokens: number;
  promptCacheReadTokens: number;
  promptAudioTokens: number;
  completionTokens: number;
  completionAudioTokens: number;
  images?: number;
  perCall?: number;
  multiple?: number;
}) {
  const cost = costOf({ model, provider });
  if (!cost) {
    return null;
  }

  let totalCost = 0;

  // Add cost for regular prompt tokens (these are the fresh, uncached tokens)
  totalCost += promptTokens * cost.prompt_token;

  // Add cost for cache write tokens if applicable
  if (cost.prompt_cache_write_token && promptCacheWriteTokens > 0) {
    totalCost += promptCacheWriteTokens * cost.prompt_cache_write_token;
  } else if (promptCacheWriteTokens > 0) {
    totalCost += promptCacheWriteTokens * cost.prompt_token;
  }

  // Add cost for cache read tokens if applicable
  if (cost.prompt_cache_read_token && promptCacheReadTokens > 0) {
    totalCost += promptCacheReadTokens * cost.prompt_cache_read_token;
  } else if (promptCacheReadTokens > 0) {
    totalCost += promptCacheReadTokens * cost.prompt_token;
  }

  // Add cost for prompt audio tokens if applicable
  if (cost.prompt_audio_token && promptAudioTokens > 0) {
    totalCost += promptAudioTokens * cost.prompt_audio_token;
  } else if (promptAudioTokens > 0) {
    totalCost += promptAudioTokens * cost.prompt_token;
  }

  // Add cost for completion tokens
  totalCost += completionTokens * cost.completion_token;

  // Add cost for completion audio tokens if applicable
  if (cost.completion_audio_token && completionAudioTokens > 0) {
    totalCost += completionAudioTokens * cost.completion_audio_token;
  } else if (completionAudioTokens > 0) {
    totalCost += completionAudioTokens * cost.completion_token;
  }

  // Add cost for images and per-call fees
  const imageCost = images * (cost.per_image ?? 0);
  const perCallCost = perCall * (cost.per_call ?? 0);
  totalCost += imageCost + perCallCost;

  if (multiple !== undefined) {
    return Math.round(totalCost * multiple);
  }

  return totalCost;
}

function caseForCost(
  costs: ModelRow[],
  table: string,
  multiple: number,
  useDefaultCost: boolean = false,
  optimized: boolean = false,
) {
  return `
  CASE
  ${costs
    .map((cost) => {
      const costPerMultiple = {
        prompt: Math.round(cost.cost.prompt_token * multiple),
        completion: Math.round(cost.cost.completion_token * multiple),
        prompt_audio: Math.round(
          (cost.cost.prompt_audio_token ?? cost.cost.prompt_token) * multiple
        ),
        completion_audio: Math.round(
          (cost.cost.completion_audio_token ?? cost.cost.completion_token) *
            multiple
        ),
        prompt_cache_write: Math.round(
          (cost.cost.prompt_cache_write_token ?? cost.cost.prompt_token) *
            multiple
        ),
        prompt_cache_read: Math.round(
          (cost.cost.prompt_cache_read_token ?? cost.cost.prompt_token) *
            multiple
        ),
        image: Math.round((cost.cost.per_image ?? 0) * multiple),
        per_call: Math.round((cost.cost.per_call ?? 0) * multiple),
      };

      const costParts = [];
      if (costPerMultiple.prompt > 0) {
        costParts.push(`${costPerMultiple.prompt} * ${table}.prompt_tokens`);
      }
      if (costPerMultiple.completion > 0) {
        costParts.push(
          `${costPerMultiple.completion} * ${table}.completion_tokens`
        );
      }
      if (costPerMultiple.prompt_audio > 0) {
        costParts.push(
          `${costPerMultiple.prompt_audio} * ${table}.prompt_audio_tokens`
        );
      }
      if (costPerMultiple.completion_audio > 0) {
        costParts.push(
          `${costPerMultiple.completion_audio} * ${table}.completion_audio_tokens`
        );
      }
      if (costPerMultiple.prompt_cache_write > 0) {
        costParts.push(
          `${costPerMultiple.prompt_cache_write} * ${table}.prompt_cache_write_tokens`
        );
      }
      if (costPerMultiple.prompt_cache_read > 0) {
        costParts.push(
          `${costPerMultiple.prompt_cache_read} * ${table}.prompt_cache_read_tokens`
        );
      }
      if (costPerMultiple.image > 0) {
        costParts.push(`${costPerMultiple.image}`); // Assuming image cost is per image, not per token
      }
      if (costPerMultiple.per_call > 0) {
        costParts.push(`${costPerMultiple.per_call}`); // Assuming per_call cost is per call
      }

      if (costParts.length > 0) {
        const costString = costParts.join(" + ");
        if (cost.model.operator === "equals") {
          const op = optimized ? "=" : "ILIKE";
          return `WHEN (${table}.model ${op} '${cost.model.value}') THEN ${costString}`;
        } else if (cost.model.operator === "startsWith") {
          return `WHEN (${table}.model LIKE '${cost.model.value}%') THEN ${costString}`;
        } else if (cost.model.operator === "includes") {
          return `WHEN (${table}.model ILIKE '%${cost.model.value}%') THEN ${costString}`;
        } else {
          throw new Error("Unknown operator");
        }
      } else {
        return ``; // Return empty string if no costs apply for this model
      }
    })
    .join("\n")}
  ELSE ${useDefaultCost ? `toInt64(${table}.cost)` : `toInt64(0)`}
END
`;
}

// Currently only used for backfilling costs via admin.
// If not chunked, the query will be too large for Clickhouse.
export function clickhousePriceCalcNonAggregated(
  table: string,
  inDollars: boolean = true,
  chunkProviders: boolean = false,
  totalChunks: number = 1,
  chunk: number = 0,
  useDefaultCost: boolean = true,
  optimized: boolean = false,
) {
  const providersWithCosts = providers.filter(
    (p) => p.costs && defaultProvider.provider !== p.provider
  );
  if (!defaultProvider.costs) {
    throw new Error("Default provider does not have costs");
  }

  const cappedTotalChunks = Math.max(1, Math.min(totalChunks, providersWithCosts.length));
  const cappedChunk = Math.min(chunk, cappedTotalChunks - 1);

  let providersToProcess = providersWithCosts;
  if (chunkProviders) {
    const chunkSize = Math.ceil(providersWithCosts.length / cappedTotalChunks);
    const start = cappedChunk * chunkSize;
    const end = Math.min(start + chunkSize, providersWithCosts.length);
    providersToProcess = providersWithCosts.slice(start, end);
  }

  if (providersToProcess.length === 0) {
    return `
  (
  CASE
    ${caseForCost(defaultProvider.costs, table, COST_PRECISION_MULTIPLIER, useDefaultCost, optimized)}
  END
  ) ${inDollars ? `/ ${COST_PRECISION_MULTIPLIER}` : ""}
`;
  }

  return `
  (
  CASE
  ${providersToProcess
    .map((provider) => {
      if (!provider.costs) {
        throw new Error("Provider does not have costs");
      }

      return `WHEN (${table}.provider = '${
        provider.provider
      }') THEN (${caseForCost(provider.costs, table, COST_PRECISION_MULTIPLIER, useDefaultCost, optimized)})`;
    })
    .join("\n")}
    ELSE ${caseForCost(defaultProvider.costs, table, COST_PRECISION_MULTIPLIER, useDefaultCost, optimized)}
  END
  ) ${inDollars ? `/ ${COST_PRECISION_MULTIPLIER}` : ""}
`;
}

export function clickhousePriceCalc(table: string, inDollars: boolean = true) {

  const providersWithCosts = providers.filter(
    (p) => p.costs && defaultProvider.provider !== p.provider
  );
  if (!defaultProvider.costs) {
    throw new Error("Default provider does not have costs");
  }
  return `
sum(
  CASE
  ${providersWithCosts
    .map((provider) => {
      if (!provider.costs) {
        throw new Error("Provider does not have costs");
      }

      return `WHEN (${table}.provider = '${
        provider.provider
      }') THEN (${caseForCost(provider.costs, table, COST_PRECISION_MULTIPLIER)})`;
    })
    .join("\n")}
    ELSE ${caseForCost(defaultProvider.costs, table, COST_PRECISION_MULTIPLIER)}
  END
  ) ${inDollars ? `/ ${COST_PRECISION_MULTIPLIER}` : ""}
`;
}
