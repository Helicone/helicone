/**
 * Utilities for sanitizing and fixing diffs generated by AI models
 * to ensure they can be correctly parsed by the diff package.
 */

import { parsePatch } from "diff";

/**
 * Sanitizes a file path by removing any 'a/' or 'b/' prefixes
 * that are typically found in diff file paths.
 */
export function sanitizeFilePath(filePath: string): string {
  // Remove 'a/' or 'b/' prefixes from file paths
  return filePath.replace(/^[ab]\//, "");
}

/**
 * Sanitizes diff content to ensure it follows the unified diff format.
 * This includes normalizing line endings and fixing common formatting issues.
 */
export function sanitizeDiffContent(diffContent: string): string {
  // Normalize line endings
  let sanitized = diffContent.replace(/\r\n/g, "\n");

  // Ensure proper spacing for context lines
  sanitized = sanitized
    .split("\n")
    .map((line) => {
      if (line.startsWith("+++") || line.startsWith("---")) {
        return line;
      }
      if (line.startsWith("@@")) {
        return line;
      }
      if (line.startsWith("+") || line.startsWith("-")) {
        return line;
      }
      if (!line.startsWith(" ")) {
        return " " + line;
      }
      return line;
    })
    .join("\n");

  return sanitized;
}

/**
 * Fixes invalid hunks in a diff by ensuring each hunk header is followed by
 * lines with proper prefixes ('+', '-', or ' ').
 * This addresses the "Hunk at line X contained invalid line" error.
 */
export function fixInvalidHunks(diffContent: string): string {
  // Split the diff into lines
  const lines = diffContent.split("\n");
  const sanitizedLines = [];

  // Process each line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Skip empty lines or lines with just whitespace at the end of the diff
    // This addresses the "Unknown line X" error
    if (i > 0 && i === lines.length - 1 && line.trim() === "") {
      continue;
    }

    // Check if this is a hunk header
    if (line.startsWith("@@ ")) {
      // Add the hunk header
      sanitizedLines.push(line);

      // Make sure the next line starts with a valid prefix ('+', '-', or ' ')
      if (i + 1 < lines.length) {
        const nextLine = lines[i + 1];
        if (
          !nextLine.startsWith("+") &&
          !nextLine.startsWith("-") &&
          !nextLine.startsWith(" ")
        ) {
          // Add a space prefix to make it a context line
          sanitizedLines.push(" " + nextLine);
          i++; // Skip this line in the next iteration
          continue;
        }
      }
    } else {
      sanitizedLines.push(line);
    }
  }

  // Remove any trailing empty lines
  while (
    sanitizedLines.length > 0 &&
    sanitizedLines[sanitizedLines.length - 1].trim() === ""
  ) {
    sanitizedLines.pop();
  }

  return sanitizedLines.join("\n");
}

/**
 * Checks if a diff is valid by attempting to parse it with the diff package.
 */
export function isValidDiff(diffContent: string): boolean {
  try {
    const patches = parsePatch(diffContent);
    return patches.length > 0;
  } catch (error) {
    return false;
  }
}

/**
 * Extracts all added lines from a diff, ignoring context and removing + prefixes.
 * This is useful for creating new files from diffs when other methods fail.
 */
export function extractAddedLines(diffContent: string): string[] {
  const lines = diffContent.split("\n");
  const addedLines: string[] = [];

  // Skip the headers (first 2 lines typically have --- and +++)
  let inHeader = true;
  let inHunk = false;

  for (const line of lines) {
    // Skip file headers
    if (line.startsWith("---") || line.startsWith("+++")) {
      continue;
    }

    // Detect start of hunk
    if (line.match(/^@@ /)) {
      inHeader = false;
      inHunk = true;
      continue;
    }

    // Only process lines if we're in a hunk
    if (inHunk) {
      if (line.startsWith("+") && !line.startsWith("+++")) {
        // Remove the + prefix
        addedLines.push(line.substring(1));
      }
    }
  }

  return addedLines;
}

/**
 * Extract the final result of what the file should look like from a diff
 * This reconstructs the content by applying the diff logic manually
 */
export function extractFinalContent(diffContent: string): string[] {
  try {
    const lines = diffContent.split("\n");
    const resultLines: string[] = [];

    // Skip to first hunk
    let i = 0;
    while (i < lines.length && !lines[i].startsWith("@@")) {
      i++;
    }

    if (i >= lines.length) {
      // No hunk found, try direct extraction
      return manuallyExtractCode(diffContent);
    }

    // Process hunks
    while (i < lines.length) {
      // Skip hunk header
      if (lines[i].startsWith("@@")) {
        i++;
        continue;
      }

      const line = lines[i];

      // Add lines that are either context (starting with space) or added (starting with +)
      if (
        (line.startsWith(" ") || line.startsWith("+")) &&
        !line.startsWith("+++")
      ) {
        // Remove the prefix character
        resultLines.push(line.substring(1));
      }

      i++;
    }

    return resultLines;
  } catch (error) {
    console.error("Error extracting final content:", error);
    return [];
  }
}

/**
 * Manually extracts code elements from a diff that might be causing parsing issues.
 * This is a more aggressive approach for when conventional methods fail.
 */
export function manuallyExtractCode(diffContent: string): string[] {
  try {
    // Look for actual content by finding code lines (filtering out diff syntax)
    const codeLines: string[] = [];
    const lines = diffContent.split("\n");

    // Skip the headers
    let i = 0;
    while (
      i < lines.length &&
      (lines[i].startsWith("---") ||
        lines[i].startsWith("+++") ||
        lines[i].startsWith("@@"))
    ) {
      i++;
    }

    // Process the rest of the lines
    for (; i < lines.length; i++) {
      const line = lines[i];

      // Extract code from added lines
      if (line.startsWith("+") && !line.startsWith("+++")) {
        codeLines.push(line.substring(1));
      }
      // Copy unchanged lines too (remove leading space if present)
      else if (!line.startsWith("-") && !line.startsWith("@@ ")) {
        codeLines.push(line.startsWith(" ") ? line.substring(1) : line);
      }
    }

    return codeLines;
  } catch (error) {
    console.error("Error manually extracting code:", error);
    return [];
  }
}

/**
 * Creates a simple diff that adds all the provided lines to a file.
 * This is useful when we need to create a new file or completely replace an existing one.
 */
export function createSimpleDiff(
  filePath: string,
  addedLines: string[]
): string {
  return [
    `--- a/${filePath}`,
    `+++ b/${filePath}`,
    `@@ -0,0 +1,${addedLines.length} @@`,
    ...addedLines.map((line) => `+${line}`),
  ].join("\n");
}

/**
 * Fixes the "Unknown line X" error by ensuring all lines in the diff have valid prefixes.
 * This is a more aggressive approach that ensures every line in the diff is valid.
 */
export function fixUnknownLineErrors(diffContent: string): string {
  // Split the diff into lines
  const lines = diffContent.split("\n");
  const sanitizedLines = [];

  let inHeader = true; // Track if we're in the header section (before first hunk)

  // Process each line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Skip empty lines at the end
    if (i === lines.length - 1 && line.trim() === "") {
      continue;
    }

    // Handle header lines (--- and +++)
    if (line.startsWith("---") || line.startsWith("+++")) {
      sanitizedLines.push(line);
      continue;
    }

    // Detect hunk headers
    if (line.startsWith("@@ ")) {
      inHeader = false; // We're now past the header section
      sanitizedLines.push(line);
      continue;
    }

    // Handle content lines based on whether we're in a hunk or not
    if (!inHeader) {
      // We're in a hunk, ensure the line has a valid prefix
      if (
        line.startsWith("+") ||
        line.startsWith("-") ||
        line.startsWith(" ")
      ) {
        sanitizedLines.push(line);
      } else if (line.trim() !== "") {
        // Add a space prefix to make it a context line
        sanitizedLines.push(" " + line);
      }
    } else {
      // We're still in the header section, just add the line as is
      sanitizedLines.push(line);
    }
  }

  return sanitizedLines.join("\n");
}
