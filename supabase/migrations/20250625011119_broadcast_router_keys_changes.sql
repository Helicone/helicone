-- CREATE OR REPLACE FUNCTION broadcast_router_keys_change() RETURNS trigger AS $$
-- DECLARE
--   owner_id uuid;
--   org_id uuid;
--   router_hash text;
--   key_hash text;
-- BEGIN
--   -- Get organization_id directly from router_keys and router_hash from routers if router_id exists
--   SELECT 
--     COALESCE(NEW.organization_id, OLD.organization_id) INTO org_id;
  
--   -- Get router_hash only if router_id is not null
--   IF COALESCE(NEW.router_id, OLD.router_id) IS NOT NULL THEN
--     SELECT r.hash INTO router_hash
--     FROM routers r
--     WHERE r.id = COALESCE(NEW.router_id, OLD.router_id);
--   ELSE
--     router_hash := NULL;
--   END IF;

--   -- Get api_key_hash from helicone_api_keys
--   SELECT api_key_hash, user_id INTO key_hash, owner_id
--   FROM helicone_api_keys
--   WHERE id = COALESCE(NEW.api_key_id, OLD.api_key_id);

--   PERFORM pg_notify(
--     'connected_cloud_gateways',           -- channel
--     json_build_object(
--       'event', 'router_keys_updated',
--       'organization_id', org_id,
--       'router_hash', router_hash,
--       'router_id', COALESCE(NEW.router_id, OLD.router_id),
--       'api_key_hash', key_hash,
--       'owner_id', owner_id,
--       'op', TG_OP
--     )::text
--   );
--   RETURN COALESCE(NEW, OLD);
-- END;
-- $$ LANGUAGE plpgsql;

-- CREATE TRIGGER t_connected_gateways_broadcast
-- AFTER INSERT OR UPDATE OR DELETE ON router_keys
-- FOR EACH ROW EXECUTE FUNCTION broadcast_router_keys_change();