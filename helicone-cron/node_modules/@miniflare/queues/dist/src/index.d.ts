import { Consumer } from '@miniflare/shared';
import { kGetConsumer } from '@miniflare/shared';
import { kSetConsumer } from '@miniflare/shared';
import { Log } from '@miniflare/shared';
import { Message as Message_2 } from '@miniflare/shared';
import { MessageBatch as MessageBatch_2 } from '@miniflare/shared';
import { MessageSendOptions } from '@miniflare/shared';
import { MessageSendRequest } from '@miniflare/shared';
import { MiniflareError } from '@miniflare/shared';
import { Plugin } from '@miniflare/shared';
import { PluginContext } from '@miniflare/shared';
import { Queue as Queue_2 } from '@miniflare/shared';
import { QueueBroker as QueueBroker_2 } from '@miniflare/shared';
import { SetupResult } from '@miniflare/shared';
import { StorageFactory } from '@miniflare/shared';

export declare interface BindingOptions {
    name: string;
    queueName: string;
}

export declare interface ConsumerOptions {
    queueName: string;
    maxBatchSize?: number;
    maxWaitMs?: number;
    maxRetries?: number;
    deadLetterQueue?: string;
}

export declare const DEFAULT_BATCH_SIZE = 5;

export declare const DEFAULT_WAIT_MS = 1000;

export declare const kSetFlushCallback: unique symbol;

declare const kShouldAttemptRetry: unique symbol;

export declare const MAX_ATTEMPTS = 3;

export declare class Message<Body = unknown> implements Message_2<Body> {
    #private;
    readonly id: string;
    readonly timestamp: Date;
    readonly body: Body;
    constructor(id: string, timestamp: Date, body: Body, log?: Log);
    retry(): void;
    [kShouldAttemptRetry](): boolean;
}

export declare class MessageBatch<Body = unknown> implements MessageBatch_2<Body> {
    readonly queue: string;
    readonly messages: Message<Body>[];
    constructor(queue: string, messages: Message<Body>[]);
    retryAll(): void;
}

export declare class Queue<Body = unknown> implements Queue_2<Body> {
    #private;
    constructor(queueName: string, log?: Log);
    send(body: Body, options?: MessageSendOptions): Promise<void>;
    sendBatch(batch: Iterable<MessageSendRequest<Body>>): Promise<void>;
    [kSetConsumer](consumer: Consumer): void;
    [kGetConsumer](): Consumer | null;
    [kSetFlushCallback](callback: () => void): void;
}

export declare class QueueBroker implements QueueBroker_2 {
    #private;
    constructor(log?: Log);
    getOrCreateQueue(name: string): Queue;
    setConsumer(queue: Queue, consumer: Consumer): void;
}

export declare class QueueError extends MiniflareError<QueueErrorCode> {
}

export declare type QueueErrorCode = "ERR_CONSUMER_ALREADY_SET";

export declare interface QueuesOptions {
    queueBindings?: BindingOptions[];
    queueConsumers?: (string | ConsumerOptions)[];
}

export declare class QueuesPlugin extends Plugin<QueuesOptions> implements QueuesOptions {
    queueBindings?: BindingOptions[];
    queueConsumers?: (string | ConsumerOptions)[];
    constructor(ctx: PluginContext, options?: QueuesOptions);
    setup(_storageFactory: StorageFactory): Promise<SetupResult>;
}

export { }
