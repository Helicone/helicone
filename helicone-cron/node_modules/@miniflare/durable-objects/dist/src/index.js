var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/durable-objects/src/index.ts
__export(exports, {
  ALARM_KEY: () => ALARM_KEY,
  AlarmStore: () => AlarmStore,
  DurableObjectError: () => DurableObjectError,
  DurableObjectId: () => DurableObjectId,
  DurableObjectNamespace: () => DurableObjectNamespace,
  DurableObjectState: () => DurableObjectState,
  DurableObjectStorage: () => DurableObjectStorage,
  DurableObjectStub: () => DurableObjectStub,
  DurableObjectTransaction: () => DurableObjectTransaction,
  DurableObjectsPlugin: () => DurableObjectsPlugin,
  ReadWriteMutex: () => ReadWriteMutex,
  ShadowStorage: () => ShadowStorage,
  _kRunWithGates: () => _kRunWithGates,
  kAlarmExists: () => kAlarmExists
});

// packages/durable-objects/src/alarms.ts
var import_assert = __toModule(require("assert"));
var ALARM_KEY = "__MINIFLARE_ALARMS__";
var AlarmStore = class {
  #store;
  #alarms = new Map();
  #alarmTimeout;
  #callback;
  async setupStore(storage, persist) {
    this.#store = storage.storage(ALARM_KEY, persist);
    const { keys } = await this.#store.list();
    for (const { name, metadata } of keys) {
      this.#alarms.set(name, { scheduledTime: metadata?.scheduledTime || 0 });
    }
  }
  #setAlarmTimeout(now, objectKey, doAlarm) {
    if (doAlarm.timeout)
      clearTimeout(doAlarm.timeout);
    doAlarm.timeout = setTimeout(() => {
      void this.#deleteAlarm(objectKey, doAlarm);
      this.#callback?.(objectKey);
    }, Math.max(doAlarm.scheduledTime - now, 0));
  }
  async setupAlarms(callback) {
    if (typeof callback === "function")
      this.#callback = callback;
    if (this.#alarmTimeout)
      return;
    const now = Date.now();
    for (const [objectKey, doAlarm] of this.#alarms) {
      const { scheduledTime } = doAlarm;
      if (scheduledTime < now + 3e4) {
        this.#setAlarmTimeout(now, objectKey, doAlarm);
      }
    }
    this.#alarmTimeout = setTimeout(() => {
      this.#alarmTimeout = void 0;
      this.setupAlarms();
    }, 3e4);
    this.#alarmTimeout.unref();
  }
  buildBridge(objectKey) {
    return {
      setAlarm: (scheduledTime) => this.setAlarm(objectKey, scheduledTime),
      deleteAlarm: () => this.deleteAlarm(objectKey)
    };
  }
  async setAlarm(objectKey, scheduledTime) {
    const now = Date.now();
    if (typeof scheduledTime !== "number")
      scheduledTime = scheduledTime.getTime();
    if (scheduledTime <= 0) {
      throw TypeError("setAlarm() cannot be called with an alarm time <= 0");
    }
    const doAlarm = this.#alarms.get(objectKey) ?? {
      scheduledTime
    };
    doAlarm.scheduledTime = scheduledTime;
    if (scheduledTime < now + 31e3) {
      this.#setAlarmTimeout(now, objectKey, doAlarm);
    }
    this.#alarms.set(objectKey, doAlarm);
    (0, import_assert.default)(this.#store);
    await this.#store.put(objectKey, {
      metadata: { scheduledTime },
      value: new Uint8Array()
    });
  }
  async deleteAlarm(key) {
    const alarm = this.#alarms.get(key);
    if (alarm)
      await this.#deleteAlarm(key, alarm);
  }
  async #deleteAlarm(key, alarm) {
    if (alarm.timeout)
      clearTimeout(alarm.timeout);
    this.#alarms.delete(key);
    (0, import_assert.default)(this.#store);
    await this.#store.delete(key);
  }
  async flushAlarms(keys) {
    if (keys === void 0) {
      for (const [key, alarm] of this.#alarms) {
        await this.#deleteAlarm(key, alarm);
        await this.#callback?.(key);
      }
    } else {
      for (const key of keys) {
        const alarm = this.#alarms.get(key);
        if (alarm !== void 0) {
          await this.#deleteAlarm(key, alarm);
          await this.#callback?.(key);
        }
      }
    }
  }
  dispose() {
    if (this.#alarmTimeout) {
      clearTimeout(this.#alarmTimeout);
      this.#alarmTimeout = void 0;
    }
    for (const doAlarm of this.#alarms.values()) {
      if (doAlarm.timeout)
        clearTimeout(doAlarm.timeout);
    }
    this.#alarms.clear();
  }
};

// packages/durable-objects/src/error.ts
var import_shared = __toModule(require("@miniflare/shared"));
var DurableObjectError = class extends import_shared.MiniflareError {
};

// packages/durable-objects/src/namespace.ts
var import_crypto = __toModule(require("crypto"));
var import_url = __toModule(require("url"));
var import_core = __toModule(require("@miniflare/core"));
var import_shared2 = __toModule(require("@miniflare/shared"));
var import_undici = __toModule(require("undici"));
function hexEncode(value) {
  return Array.from(value).map((byte) => byte.toString(16).padStart(2, "0")).join("");
}
var kObjectName = Symbol("kObjectName");
var DurableObjectId = class {
  constructor(objectName, hexId, name) {
    this.name = name;
    this[kObjectName] = objectName;
    this.#hexId = hexId;
  }
  [kObjectName];
  #hexId;
  equals(other) {
    if (!(other instanceof DurableObjectId))
      return false;
    return this.#hexId === other.#hexId;
  }
  toString() {
    return this.#hexId;
  }
};
var kInstance = Symbol("kInstance");
var _kRunWithGates = Symbol("kRunWithGates");
var kAlarm = Symbol("kAlarm");
var kFetch = Symbol("kFetch");
var DurableObjectState = class {
  constructor(id, storage) {
    this.id = id;
    this.storage = storage;
  }
  #inputGate = new import_shared2.InputGate();
  [kInstance];
  waitUntil(_promise) {
  }
  blockConcurrencyWhile(closure) {
    return this.#inputGate.runWithClosed(closure);
  }
  [_kRunWithGates](closure) {
    const outputGate = new import_shared2.OutputGate();
    return outputGate.runWith(() => this.#inputGate.runWith(closure));
  }
  [kFetch](request) {
    return this[_kRunWithGates](() => {
      const instance = this[kInstance];
      if (!instance?.fetch) {
        throw new DurableObjectError("ERR_NO_HANDLER", "No fetch handler defined in Durable Object");
      }
      return instance.fetch(request);
    });
  }
  [kAlarm]() {
    return this[_kRunWithGates](async () => {
      await this.storage.deleteAlarm();
      const instance = this[kInstance];
      if (!instance?.alarm) {
        throw new DurableObjectError("ERR_NO_HANDLER", "No alarm handler defined in Durable Object");
      }
      return instance.alarm();
    });
  }
};
var DurableObjectStub = class {
  constructor(factory, id, ctx) {
    this.id = id;
    this.#factory = factory;
    this.#ctx = ctx;
  }
  #factory;
  #ctx;
  get name() {
    return this.id.name;
  }
  async fetch(input, init) {
    const state = await this.#factory(this.id);
    if (!this.#ctx?.compat.isEnabled("durable_object_fetch_requires_full_url") && typeof input === "string") {
      input = new import_url.URL(input, "https://fake-host");
    }
    const url = (0, import_core._urlFromRequestInput)(input);
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      if (this.#ctx?.compat.isEnabled("fetch_refuses_unknown_protocols")) {
        throw new TypeError(`Fetch API cannot load: ${url.toString()}`);
      } else {
        this.#ctx?.log.warn((0, import_core._buildUnknownProtocolWarning)(url));
      }
    }
    const req = input instanceof import_core.Request && !init ? input : new import_core.Request(input, init);
    const parentContext = (0, import_shared2.getRequestContext)();
    parentContext?.incrementInternalSubrequests();
    const requestDepth = (parentContext?.requestDepth ?? 0) + 1;
    const res = await new import_shared2.RequestContext({
      requestDepth,
      pipelineDepth: 1,
      durableObject: true,
      externalSubrequestLimit: (0, import_shared2.usageModelExternalSubrequestLimit)(this.#ctx?.usageModel)
    }).runWith(() => state[kFetch]((0, import_core.withInputGating)((0, import_core.withImmutableHeaders)(req))));
    parentContext?.advanceCurrentTime();
    const validRes = res instanceof import_core.Response || res instanceof import_undici.Response;
    if (!validRes) {
      throw new DurableObjectError("ERR_RESPONSE_TYPE", "Durable Object fetch handler didn't respond with a Response object");
    }
    return (0, import_core.withImmutableHeaders)(res);
  }
};
var HEX_ID_REGEXP = /^[A-Za-z0-9]{64}$/;
var DurableObjectNamespace = class {
  #objectName;
  #factory;
  #objectNameHash;
  #objectNameHashHex;
  #ctx;
  constructor(objectName, factory, ctx) {
    this.#objectName = objectName;
    this.#factory = factory;
    this.#objectNameHash = (0, import_crypto.createHash)("sha256").update(this.#objectName).digest().slice(0, 8);
    this.#objectNameHashHex = hexEncode(this.#objectNameHash);
    this.#ctx = ctx;
  }
  newUniqueId(_options) {
    const id = new Uint8Array(32);
    const view = new DataView(id.buffer);
    view.setBigUint64(1, BigInt(Date.now()));
    import_crypto.webcrypto.getRandomValues(new Uint8Array(id.buffer, 9, 15));
    id.set(this.#objectNameHash, 24);
    return new DurableObjectId(this.#objectName, hexEncode(id));
  }
  idFromName(name) {
    const id = (0, import_crypto.createHash)("sha256").update(this.#objectName).update(name).digest();
    id[0] |= 128;
    id.set(this.#objectNameHash, 24);
    return new DurableObjectId(this.#objectName, hexEncode(id), name);
  }
  idFromString(hexId) {
    if (!HEX_ID_REGEXP.test(hexId)) {
      throw new TypeError("Invalid Durable Object ID. Durable Object IDs must be 64 hex digits.");
    }
    if (!hexId.endsWith(this.#objectNameHashHex)) {
      throw new TypeError("Invalid Durable Object ID. The ID does not match this Durable Object class.");
    }
    return new DurableObjectId(this.#objectName, hexId.toLowerCase());
  }
  get(id) {
    if (id[kObjectName] !== this.#objectName || !id.toString().endsWith(this.#objectNameHashHex)) {
      throw new TypeError("ID is not for this Durable Object class.");
    }
    return new DurableObjectStub(this.#factory, id, this.#ctx);
  }
};

// packages/durable-objects/src/plugin.ts
var import_assert4 = __toModule(require("assert"));
var import_shared5 = __toModule(require("@miniflare/shared"));

// packages/durable-objects/src/storage.ts
var import_assert3 = __toModule(require("assert"));
var import_v8 = __toModule(require("v8"));
var import_shared4 = __toModule(require("@miniflare/shared"));

// packages/durable-objects/src/rwmutex.ts
var ReadWriteMutex = class {
  readLockCount = 0;
  writeLocked = false;
  readResolveQueue = [];
  writeResolveQueue = [];
  readLock() {
    if (this.writeResolveQueue.length === 0 && !this.writeLocked) {
      this.readLockCount++;
      return;
    }
    return new Promise((resolve) => this.readResolveQueue.push(resolve));
  }
  writeLock() {
    if (this.readLockCount === 0 && !this.writeLocked) {
      this.writeLocked = true;
      return;
    }
    return new Promise((resolve) => this.writeResolveQueue.push(resolve));
  }
  unlock() {
    if (this.readLockCount > 0)
      return;
    if (this.writeResolveQueue.length > 0) {
      this.writeLocked = true;
      return this.writeResolveQueue.shift()?.();
    }
    this.writeLocked = false;
    this.readLockCount += this.readResolveQueue.length;
    for (const resolve of this.readResolveQueue)
      resolve();
    this.readResolveQueue.splice(0, this.readResolveQueue.length);
  }
  async runWithRead(closure) {
    const acquireAwaitable = this.readLock();
    if (acquireAwaitable instanceof Promise)
      await acquireAwaitable;
    try {
      const awaitable = closure();
      if (awaitable instanceof Promise)
        return await awaitable;
      return awaitable;
    } finally {
      this.readLockCount--;
      this.unlock();
    }
  }
  async runWithWrite(closure) {
    const acquireAwaitable = this.writeLock();
    if (acquireAwaitable instanceof Promise)
      await acquireAwaitable;
    try {
      const awaitable = closure();
      if (awaitable instanceof Promise)
        return await awaitable;
      return awaitable;
    } finally {
      this.unlock();
    }
  }
};

// packages/durable-objects/src/shadow.ts
var import_assert2 = __toModule(require("assert"));
var import_shared3 = __toModule(require("@miniflare/shared"));
var import_storage_memory = __toModule(require("@miniflare/storage-memory"));
var ShadowStorage = class extends import_shared3.Storage {
  constructor(inner, recordReads = true) {
    super();
    this.inner = inner;
    if (recordReads)
      this.readSet = new Set();
  }
  readSet;
  copies = new Map();
  alarm;
  async has(key) {
    return await this.hasMany([key]) > 0;
  }
  async hasMany(keys) {
    if (this.readSet)
      (0, import_shared3.addAll)(this.readSet, keys);
    if (this.copies.size === 0)
      return this.inner.hasMany(keys);
    let count = 0;
    const innerHasKeys = [];
    for (const key of keys) {
      if (this.copies.has(key)) {
        if (this.copies.get(key) !== void 0)
          count++;
      } else {
        innerHasKeys.push(key);
      }
    }
    count += await this.inner.hasMany(innerHasKeys);
    return count;
  }
  async head(_key) {
    throw new Error('"head" is not supported in Durable Object shadow storage');
  }
  async get(key) {
    return (await this.getMany([key]))[0];
  }
  async getMany(keys) {
    if (this.readSet)
      (0, import_shared3.addAll)(this.readSet, keys);
    if (this.copies.size === 0)
      return this.inner.getMany(keys, true);
    const result = new Array(keys.length);
    const innerGetKeys = [];
    const innerGetIndices = [];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (this.copies.has(key)) {
        const copy = this.copies.get(key);
        result[i] = copy && { value: copy.value.slice() };
      } else {
        innerGetKeys.push(key);
        innerGetIndices.push(i);
      }
    }
    import_assert2.default.strictEqual(innerGetKeys.length, innerGetIndices.length);
    if (innerGetKeys.length === 0)
      return result;
    const innerGetResult = await this.inner.getMany(innerGetKeys, true);
    import_assert2.default.strictEqual(innerGetKeys.length, innerGetResult.length);
    for (let i = 0; i < innerGetKeys.length; i++) {
      result[innerGetIndices[i]] = innerGetResult[i];
    }
    return result;
  }
  async getRange(_key) {
    throw new Error('"getRange" is not supported in Durable Object shadow storage');
  }
  put(key, value) {
    this.copies.set(key, { value: value.value.slice() });
  }
  async delete(key) {
    return await this.deleteMany([key]) > 0;
  }
  async deleteMany(keys) {
    const deleted = await this.hasMany(keys);
    for (const key of keys)
      this.copies.set(key, void 0);
    return deleted;
  }
  async list(options) {
    if (this.copies.size === 0) {
      const { keys: keys2 } = await this.inner.list(options, true);
      if (this.readSet) {
        (0, import_shared3.addAll)(this.readSet, keys2.map(({ name }) => name));
      }
      return { keys: keys2, cursor: "" };
    }
    const matchingCopies = new Map();
    let deletedMatchingCopies = 0;
    for (const [key, value] of this.copies.entries()) {
      if ((0, import_storage_memory.listFilterMatch)(options, key)) {
        matchingCopies.set(key, value);
        if (value === void 0)
          deletedMatchingCopies++;
      }
    }
    let { keys } = await this.inner.list({
      ...options,
      limit: options?.limit && options.limit + deletedMatchingCopies
    }, true);
    keys = keys.filter((stored) => {
      if (matchingCopies.has(stored.name)) {
        const matching = matchingCopies.get(stored.name);
        matchingCopies.delete(stored.name);
        if (matching === void 0)
          return false;
      }
      return true;
    });
    for (const [key, value] of matchingCopies.entries()) {
      if (value)
        keys.push({ name: key });
    }
    const direction = options?.reverse ? -1 : 1;
    keys.sort((a, b) => direction * (0, import_shared3.lexicographicCompare)(a.name, b.name));
    if (options?.limit)
      keys = keys.slice(0, options.limit);
    if (this.readSet) {
      (0, import_shared3.addAll)(this.readSet, keys.map(({ name }) => name));
    }
    return { keys, cursor: "" };
  }
  async getAlarm() {
    this.readSet?.add(ALARM_KEY);
    if (this.alarm !== void 0)
      return this.alarm;
    const { metadata } = await this.inner.get(ALARM_KEY) ?? {};
    return metadata?.scheduledTime ?? null;
  }
  setAlarm(scheduledTime) {
    if (typeof scheduledTime !== "number")
      scheduledTime = scheduledTime.getTime();
    this.alarm = scheduledTime;
    return Promise.resolve();
  }
  deleteAlarm() {
    this.alarm = null;
    return Promise.resolve();
  }
};

// packages/durable-objects/src/storage.ts
var MAX_KEYS = 128;
var MAX_KEY_SIZE = 2048;
var MAX_VALUE_SIZE = 128 * 1024;
var ENFORCED_MAX_VALUE_SIZE = MAX_VALUE_SIZE + 32;
var undefinedKeyError = ": parameter 1 is not of type 'variant'. (key is undefined)";
function intersects(a, b) {
  for (const value of a)
    if (b.has(value))
      return true;
  return false;
}
function assertKeySize(key, many = false) {
  if (Buffer.byteLength(key) <= MAX_KEY_SIZE)
    return;
  if (many) {
    throw new RangeError(`Key "${key}" is larger than the limit of ${MAX_KEY_SIZE} bytes.`);
  }
  throw new RangeError(`Keys cannot be larger than ${MAX_KEY_SIZE} bytes.`);
}
function assertValueSize(value, key) {
  if (value.byteLength <= ENFORCED_MAX_VALUE_SIZE)
    return;
  if (key !== void 0) {
    throw new RangeError(`Value for key "${key}" is above the limit of ${MAX_VALUE_SIZE} bytes.`);
  }
  throw new RangeError(`Values cannot be larger than ${MAX_VALUE_SIZE} bytes.`);
}
function helpfulDeserialize(buffer) {
  try {
    return (0, import_v8.deserialize)(buffer);
  } catch (e) {
    throw new DurableObjectError("ERR_DESERIALIZATION", "Unable to deserialize stored Durable Object data due to an invalid or unsupported version.\nThe Durable Object data storage format changed in Miniflare 2. You cannot load Durable Object data created with Miniflare 1 and must delete it.", e);
  }
}
async function get(storage, keys, listing = false) {
  if (Array.isArray(keys)) {
    if (!listing && keys.length > MAX_KEYS) {
      throw new RangeError(`Maximum number of keys is ${MAX_KEYS}.`);
    }
    const defined = [];
    for (const key of keys) {
      if (key === void 0)
        continue;
      defined.push(key);
      assertKeySize(key, true);
    }
    if (!listing) {
      defined.sort(import_shared4.lexicographicCompare);
    }
    const res = new Map();
    const values = await storage.getMany(defined);
    import_assert3.default.strictEqual(defined.length, values.length);
    for (let i = 0; i < defined.length; i++) {
      const value2 = values[i];
      if (value2 !== void 0) {
        res.set(defined[i], helpfulDeserialize(value2.value));
      }
    }
    return res;
  }
  assertKeySize(keys);
  const value = await storage.get(keys);
  return value && helpfulDeserialize(value.value);
}
async function list(storage, options = {}) {
  if (options.limit !== void 0 && options.limit <= 0) {
    throw new TypeError("List limit must be positive.");
  }
  if (options.start !== void 0 && options.startAfter !== void 0) {
    throw new TypeError("list() cannot be called with both start and startAfter values.");
  }
  options = { ...options };
  const originalLimit = options.limit;
  if (options.limit !== void 0)
    options.limit++;
  if (options.startAfter !== void 0) {
    options.start = options.startAfter;
    if (options.limit !== void 0)
      options.limit++;
  }
  const { keys } = await storage.list(options);
  let keyNames = keys.map(({ name }) => name).filter((name) => name !== ALARM_KEY);
  if (options.startAfter !== void 0 && keyNames[0] === options.startAfter) {
    keyNames.splice(0, 1);
  }
  if (originalLimit !== void 0)
    keyNames = keyNames.slice(0, originalLimit);
  return get(storage, keyNames, true);
}
function normalisePutEntries(keyEntries, valueOptions) {
  if (typeof keyEntries === "string") {
    assertKeySize(keyEntries);
    if (valueOptions === void 0) {
      throw new TypeError("put() called with undefined value.");
    }
    const serialized = (0, import_v8.serialize)(valueOptions);
    assertValueSize(serialized);
    return [[keyEntries, { value: (0, import_shared4.viewToArray)(serialized) }]];
  }
  const entries = Object.entries(keyEntries);
  if (entries.length > MAX_KEYS) {
    throw new RangeError(`Maximum number of pairs is ${MAX_KEYS}.`);
  }
  const result = [];
  for (const [key, rawValue] of entries) {
    assertKeySize(key, true);
    if (rawValue === void 0)
      continue;
    const serialized = (0, import_v8.serialize)(rawValue);
    assertValueSize(serialized, key);
    result.push([key, { value: (0, import_shared4.viewToArray)(serialized) }]);
  }
  return result;
}
function normaliseDeleteKeys(keys) {
  if (Array.isArray(keys)) {
    if (keys.length > MAX_KEYS) {
      throw new RangeError(`Maximum number of keys is ${MAX_KEYS}.`);
    }
    const defined = [];
    for (const key of keys) {
      if (key === void 0)
        continue;
      assertKeySize(key, true);
      defined.push(key);
    }
    return defined;
  } else {
    assertKeySize(keys);
    return [keys];
  }
}
var kInner = Symbol("kInner");
var kStartTxnCount = Symbol("kStartTxnCount");
var kRolledback = Symbol("kRolledback");
var kCommitted = Symbol("kCommitted");
var kWriteSet = Symbol("kWriteSet");
var kAlarmExists = Symbol("kAlarmExists");
var DurableObjectTransaction = class {
  #mutex = new ReadWriteMutex();
  [kInner];
  [kStartTxnCount];
  [kRolledback] = false;
  [kCommitted] = false;
  [kWriteSet] = new Set();
  [kAlarmExists];
  constructor(inner, startTxnCount, alarmExists) {
    this[kInner] = new ShadowStorage(inner);
    this[kStartTxnCount] = startTxnCount;
    this[kAlarmExists] = alarmExists;
  }
  #check(op) {
    if (this[kRolledback]) {
      throw new Error(`Cannot ${op}() on rolled back transaction`);
    }
    if (this[kCommitted]) {
      throw new Error(`Cannot call ${op}() on transaction that has already committed: did you move \`txn\` outside of the closure?`);
    }
  }
  #markWritten(...keys) {
    (0, import_shared4.addAll)(this[kWriteSet], keys);
    if (this[kWriteSet].size > MAX_KEYS) {
      throw new Error(`Maximum number of keys modified in a transaction is ${MAX_KEYS}.`);
    }
  }
  get(keys, options) {
    if (keys === void 0) {
      throw new TypeError("Failed to execute 'get' on 'DurableObjectTransaction'" + undefinedKeyError);
    }
    this.#check("get");
    return (0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithRead(() => get(this[kInner], keys)), options?.allowConcurrency);
  }
  #put(keyEntries, valueOptions) {
    const entries = normalisePutEntries(keyEntries, valueOptions);
    this.#markWritten(...entries.map(([key]) => key));
    return this[kInner].putMany(entries);
  }
  put(keyEntries, valueOptions, options) {
    if (keyEntries === void 0) {
      throw new TypeError("Failed to execute 'put' on 'DurableObjectTransaction'" + undefinedKeyError);
    }
    this.#check("put");
    if (!options && typeof keyEntries !== "string")
      options = valueOptions;
    return (0, import_shared4.waitUntilOnOutputGate)((0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithWrite(() => this.#put(keyEntries, valueOptions)), options?.allowConcurrency), options?.allowUnconfirmed);
  }
  #delete(keys) {
    const keysIsArray = Array.isArray(keys);
    keys = normaliseDeleteKeys(keys);
    this.#markWritten(...keys);
    return keysIsArray ? this[kInner].deleteMany(keys) : Promise.resolve(this[kInner].delete(keys[0]));
  }
  delete(keys, options) {
    if (keys === void 0) {
      throw new TypeError("Failed to execute 'delete' on 'DurableObjectTransaction'" + undefinedKeyError);
    }
    this.#check("delete");
    return (0, import_shared4.waitUntilOnOutputGate)((0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithWrite(() => this.#delete(keys)), options?.allowConcurrency), options?.allowUnconfirmed);
  }
  deleteAll() {
    throw new Error("Cannot call deleteAll() within a transaction");
  }
  list(options = {}) {
    this.#check("list");
    return (0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithRead(() => list(this[kInner], options)), options.allowConcurrency);
  }
  async getAlarm(options) {
    this.#check("getAlarm");
    if (!this[kAlarmExists])
      return null;
    return (0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithRead(() => this[kInner].getAlarm()), options?.allowConcurrency);
  }
  setAlarm(scheduledTime, options) {
    this.#check("setAlarm");
    if (!this[kAlarmExists]) {
      throw new Error("Your Durable Object class must have an alarm() handler in order to call setAlarm()");
    }
    return (0, import_shared4.waitUntilOnOutputGate)((0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithWrite(() => this[kInner].setAlarm(scheduledTime)), options?.allowConcurrency), options?.allowUnconfirmed);
  }
  deleteAlarm(options) {
    this.#check("deleteAlarm");
    return (0, import_shared4.waitUntilOnOutputGate)((0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithWrite(() => this[kInner].deleteAlarm()), options?.allowConcurrency), options?.allowUnconfirmed);
  }
  rollback() {
    if (this[kRolledback])
      return;
    this.#check("rollback");
    this[kRolledback] = true;
  }
};
var txnWriteSetsMaxSize = 16;
function runWithGatesClosed(closure, options) {
  return (0, import_shared4.waitUntilOnOutputGate)((0, import_shared4.runWithInputGateClosed)(closure, options?.allowConcurrency), options?.allowUnconfirmed);
}
var DurableObjectStorage = class {
  #mutex = new ReadWriteMutex();
  #txnCount = 0;
  #txnWriteSets = new Map();
  #deletedKeySets = [];
  #deletedKeyResults = new Map();
  #inner;
  #shadow;
  #alarmBridge;
  [kAlarmExists] = true;
  constructor(inner, alarmBridge) {
    this.#inner = inner;
    this.#alarmBridge = alarmBridge;
    this.#shadow = new ShadowStorage(inner, false);
  }
  async #txnRead(closure) {
    const startTxnCount = this.#txnCount;
    const txn = new DurableObjectTransaction(this.#shadow, startTxnCount, this[kAlarmExists]);
    const result = await closure(txn);
    txn[kCommitted] = true;
    return { txn, result };
  }
  async #txnValidateWrite(txn) {
    if (txn[kRolledback])
      return true;
    return this.#mutex.runWithWrite(async () => {
      const finishTxnCount = this.#txnCount;
      const readSet = txn[kInner].readSet;
      for (let t = txn[kStartTxnCount] + 1; t <= finishTxnCount; t++) {
        const otherWriteSet = this.#txnWriteSets.get(t);
        if (!otherWriteSet || intersects(otherWriteSet, readSet)) {
          return false;
        }
      }
      this.#txnRecordWriteSet(txn[kWriteSet]);
      for (const [key, value] of txn[kInner].copies.entries()) {
        this.#shadow.copies.set(key, value);
      }
      this.#shadow.alarm = txn[kInner].alarm;
      await this.#flush();
      return true;
    });
  }
  #txnRecordWriteSet(writeSet) {
    this.#txnCount++;
    this.#txnWriteSets.set(this.#txnCount, writeSet);
    this.#txnWriteSets.delete(this.#txnCount - txnWriteSetsMaxSize);
  }
  transaction(closure) {
    return runWithGatesClosed(async () => {
      while (true) {
        const outputGate = new import_shared4.OutputGate();
        const { txn, result } = await outputGate.runWith(() => this.#txnRead(closure));
        if (await this.#txnValidateWrite(txn))
          return result;
      }
    });
  }
  async get(keys, options) {
    if (keys === void 0) {
      throw new TypeError("Failed to execute 'get' on 'DurableObjectStorage'" + undefinedKeyError);
    }
    return (0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithRead(() => get(this.#shadow, keys)), options?.allowConcurrency);
  }
  #flush = async () => {
    if (typeof this.#shadow.alarm === "number") {
      await this.#inner.put(ALARM_KEY, {
        metadata: { scheduledTime: this.#shadow.alarm },
        value: new Uint8Array()
      });
      await this.#alarmBridge?.setAlarm(this.#shadow.alarm);
    } else if (this.#shadow.alarm === null) {
      await this.#inner.delete(ALARM_KEY);
      await this.#alarmBridge?.deleteAlarm();
    }
    this.#shadow.alarm = void 0;
    if (this.#shadow.copies.size === 0) {
      import_assert3.default.strictEqual(this.#deletedKeySets.length, 0);
      return;
    }
    const deletedKeySets = this.#deletedKeySets;
    this.#deletedKeySets = [];
    const entries = [...this.#shadow.copies.entries()];
    const allDeletedKeys = new Set();
    for (const deleteKeySet of deletedKeySets) {
      const result = await this.#inner.deleteMany(deleteKeySet);
      this.#deletedKeyResults.set(deleteKeySet, result);
      (0, import_shared4.addAll)(allDeletedKeys, deleteKeySet);
    }
    const putEntries = [];
    const deleteKeys = [];
    for (const [key, value] of entries) {
      if (value)
        putEntries.push([key, value]);
      else if (!allDeletedKeys.has(key))
        deleteKeys.push(key);
    }
    if (putEntries.length > 0)
      await this.#inner.putMany(putEntries);
    if (deleteKeys.length > 0)
      await this.#inner.deleteMany(deleteKeys);
    for (const [key, value] of entries) {
      if (this.#shadow.copies.get(key) === value) {
        this.#shadow.copies.delete(key);
      }
    }
  };
  put(keyEntries, valueOptions, options) {
    if (keyEntries === void 0) {
      throw new TypeError("Failed to execute 'put' on 'DurableObjectStorage'" + undefinedKeyError);
    }
    const entries = normalisePutEntries(keyEntries, valueOptions);
    if (!options && typeof keyEntries !== "string")
      options = valueOptions;
    return runWithGatesClosed(async () => {
      await this.#mutex.runWithWrite(() => {
        for (const [key, value] of entries)
          this.#shadow.put(key, value);
        this.#txnRecordWriteSet(new Set(entries.map(([key]) => key)));
      });
      await Promise.resolve();
      return this.#mutex.runWithWrite(this.#flush);
    }, options);
  }
  delete(keys, options) {
    if (keys === void 0) {
      throw new TypeError("Failed to execute 'delete' on 'DurableObjectStorage'" + undefinedKeyError);
    }
    const keysIsArray = Array.isArray(keys);
    keys = normaliseDeleteKeys(keys);
    let deleted = 0;
    const deletedKeySet = [];
    return runWithGatesClosed(async () => {
      await this.#mutex.runWithWrite(() => {
        for (const key of keys) {
          if (key === void 0)
            continue;
          if (this.#shadow.copies.has(key)) {
            if (this.#shadow.copies.get(key) !== void 0) {
              deleted++;
            }
          } else {
            deletedKeySet.push(key);
          }
          this.#shadow.copies.set(key, void 0);
        }
        if (deletedKeySet.length)
          this.#deletedKeySets.push(deletedKeySet);
        this.#txnRecordWriteSet(new Set(keys));
      });
      await Promise.resolve();
      return this.#mutex.runWithWrite(async () => {
        await this.#flush();
        if (deletedKeySet.length) {
          (0, import_assert3.default)(!this.#deletedKeySets.includes(deletedKeySet));
          const result = this.#deletedKeyResults.get(deletedKeySet);
          this.#deletedKeyResults.delete(deletedKeySet);
          (0, import_assert3.default)(result !== void 0);
          deleted += result;
        }
        return keysIsArray ? deleted : deleted > 0;
      });
    }, options);
  }
  async deleteAll(options) {
    return runWithGatesClosed(() => this.#mutex.runWithWrite(async () => {
      const { keys } = await this.#shadow.list();
      const names = keys.map(({ name }) => name);
      for (const key of names)
        this.#shadow.copies.set(key, void 0);
      this.#txnRecordWriteSet(new Set(names));
      await this.#flush();
    }), options);
  }
  async list(options) {
    return (0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithRead(() => list(this.#shadow, options)), options?.allowConcurrency);
  }
  async getAlarm(options) {
    if (!this[kAlarmExists])
      return null;
    return (0, import_shared4.runWithInputGateClosed)(() => this.#mutex.runWithRead(() => this.#shadow.getAlarm()), options?.allowConcurrency);
  }
  async setAlarm(scheduledTime, options) {
    if (!this[kAlarmExists]) {
      throw new Error("Your Durable Object class must have an alarm() handler in order to call setAlarm()");
    }
    return runWithGatesClosed(async () => {
      await this.#mutex.runWithWrite(async () => {
        await this.#shadow.setAlarm(scheduledTime);
        this.#txnRecordWriteSet(new Set([ALARM_KEY]));
      });
      await Promise.resolve();
      return this.#mutex.runWithWrite(this.#flush);
    }, options);
  }
  async deleteAlarm(options) {
    return runWithGatesClosed(async () => {
      await this.#mutex.runWithWrite(async () => {
        await this.#shadow.deleteAlarm();
        this.#txnRecordWriteSet(new Set([ALARM_KEY]));
      });
      await Promise.resolve();
      return this.#mutex.runWithWrite(this.#flush);
    }, options);
  }
};

// packages/durable-objects/src/plugin.ts
function getObjectKeyFromId(id) {
  return `${id[kObjectName]}:${id.toString()}`;
}
function getObjectIdFromKey(key) {
  const colonIndex = key.lastIndexOf(":");
  const objectName = key.substring(0, colonIndex);
  const hexId = key.substring(colonIndex + 1);
  return new DurableObjectId(objectName, hexId);
}
var DurableObjectsPlugin = class extends import_shared5.Plugin {
  durableObjects;
  durableObjectsPersist;
  durableObjectsAlarms;
  #persist;
  #processedObjects;
  #requireFullUrl;
  #contextPromise;
  #contextResolve;
  #constructors = new Map();
  #bindings = {};
  #objectStorages = new Map();
  #objectStates = new Map();
  #alarmStore;
  #alarmStoreCallback;
  #alarmStoreCallbackAttached = false;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
    this.#persist = (0, import_shared5.resolveStoragePersist)(ctx.rootPath, this.durableObjectsPersist);
    this.#alarmStore = new AlarmStore();
    this.#processedObjects = Object.entries(this.durableObjects ?? {}).map(([name, options2]) => {
      const className = typeof options2 === "object" ? options2.className : options2;
      const scriptName = typeof options2 === "object" ? options2.scriptName : void 0;
      return { name, className, scriptName };
    });
    this.#requireFullUrl = ctx.compat.isEnabled("durable_object_fetch_requires_full_url");
  }
  getStorage(storage, id) {
    const key = getObjectKeyFromId(id);
    let objectStorage = this.#objectStorages.get(key);
    if (objectStorage !== void 0)
      return objectStorage;
    objectStorage = new DurableObjectStorage(storage.storage(key, this.#persist), this.#alarmStore.buildBridge(key));
    this.#objectStorages.set(key, objectStorage);
    return objectStorage;
  }
  async getObject(storage, id) {
    (0, import_assert4.default)(this.#contextPromise, "beforeReload() must be called before getObject()");
    await this.#contextPromise;
    const key = getObjectKeyFromId(id);
    let state = this.#objectStates.get(key);
    if (state !== void 0)
      return state;
    const objectName = id[kObjectName];
    const unnamedId = new DurableObjectId(objectName, id.toString());
    const objectStorage = this.getStorage(storage, id);
    state = new DurableObjectState(unnamedId, objectStorage);
    this.#objectStates.set(key, state);
    const constructor = this.#constructors.get(objectName);
    (0, import_assert4.default)(constructor);
    state[kInstance] = new constructor(state, this.#bindings);
    if (!state[kInstance]?.alarm)
      objectStorage[kAlarmExists] = false;
    return state;
  }
  getNamespace(storage, objectName) {
    const factory = (id) => this.getObject(storage, id);
    return new DurableObjectNamespace(objectName, factory, this.ctx);
  }
  async setup(storageFactory) {
    const bindings = {};
    for (const { name } of this.#processedObjects) {
      bindings[name] = this.getNamespace(storageFactory, name);
    }
    await this.#setupAlarms(storageFactory);
    return {
      bindings,
      requiresModuleExports: this.#processedObjects.length > 0
    };
  }
  async #setupAlarms(storageFactory) {
    if (this.durableObjectsAlarms === false)
      return;
    await this.#alarmStore.setupStore(storageFactory, this.#persist);
    this.#alarmStoreCallback = async (objectKey) => {
      const id = getObjectIdFromKey(objectKey);
      const state = await this.getObject(storageFactory, id);
      await this.#executeAlarm(state);
    };
  }
  flushAlarms(storageFactory, ids) {
    return this.#alarmStore.flushAlarms(ids?.map(getObjectKeyFromId));
  }
  async #executeAlarm(state) {
    await new import_shared5.RequestContext({
      requestDepth: 1,
      pipelineDepth: 1,
      durableObject: true,
      externalSubrequestLimit: (0, import_shared5.usageModelExternalSubrequestLimit)(this.ctx.usageModel)
    }).runWith(() => state[kAlarm]());
  }
  async beforeReload() {
    this.#objectStorages.clear();
    this.#objectStates.clear();
    this.#contextPromise = new Promise((resolve) => this.#contextResolve = resolve);
    if (!this.#alarmStoreCallbackAttached && this.#alarmStoreCallback !== void 0) {
      this.#alarmStoreCallbackAttached = true;
      await this.#alarmStore.setupAlarms(this.#alarmStoreCallback);
    }
  }
  reload(bindings, moduleExports, mounts) {
    this.#constructors.clear();
    for (const { name, className, scriptName } of this.#processedObjects) {
      let constructor;
      if (scriptName === void 0) {
        constructor = moduleExports[className];
      } else {
        const scriptExports = mounts.get(scriptName)?.moduleExports;
        if (!scriptExports) {
          throw new DurableObjectError("ERR_SCRIPT_NOT_FOUND", `Script "${scriptName}" for Durable Object "${name}" not found.
Make sure "${scriptName}" is mounted so Miniflare knows where to find it.`);
        }
        constructor = scriptExports[className];
      }
      if (constructor) {
        this.#constructors.set(name, constructor);
      } else {
        const script = scriptName ? ` in script "${scriptName}"` : "";
        throw new DurableObjectError("ERR_CLASS_NOT_FOUND", `Class "${className}"${script} for Durable Object "${name}" not found`);
      }
    }
    this.#bindings = bindings;
    (0, import_assert4.default)(this.#contextResolve, "beforeReload() must be called before reload()");
    this.#contextResolve();
  }
  async dispose() {
    await this.beforeReload();
    this.#alarmStore.dispose();
  }
};
__decorateClass([
  (0, import_shared5.Option)({
    type: import_shared5.OptionType.OBJECT,
    typeFormat: "NAME=CLASS[@MOUNT]",
    name: "do",
    alias: "o",
    description: "Durable Object to bind",
    fromEntries: (entries) => Object.fromEntries(entries.map(([name, classScriptName]) => {
      const atIndex = classScriptName.lastIndexOf("@");
      if (atIndex === -1) {
        return [name, classScriptName];
      } else {
        const className = classScriptName.substring(0, atIndex);
        const scriptName = classScriptName.substring(atIndex + 1);
        return [name, { className, scriptName }];
      }
    })),
    fromWrangler: ({ durable_objects }) => durable_objects?.bindings?.reduce((objects, { name, class_name, script_name }) => {
      objects[name] = { className: class_name, scriptName: script_name };
      return objects;
    }, {})
  })
], DurableObjectsPlugin.prototype, "durableObjects", 2);
__decorateClass([
  (0, import_shared5.Option)({
    type: import_shared5.OptionType.BOOLEAN_STRING,
    name: "do-persist",
    description: "Persist Durable Object data (to optional path)",
    logName: "Durable Objects Persistence",
    fromWrangler: ({ miniflare }) => miniflare?.durable_objects_persist
  })
], DurableObjectsPlugin.prototype, "durableObjectsPersist", 2);
__decorateClass([
  (0, import_shared5.Option)({
    type: import_shared5.OptionType.BOOLEAN,
    name: "do-alarms",
    description: "Enable Durable Object alarms (enabled by default)",
    negatable: true,
    logName: "Durable Object Alarms",
    fromWrangler: ({ miniflare }) => miniflare?.durable_objects_alarms
  })
], DurableObjectsPlugin.prototype, "durableObjectsAlarms", 2);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ALARM_KEY,
  AlarmStore,
  DurableObjectError,
  DurableObjectId,
  DurableObjectNamespace,
  DurableObjectState,
  DurableObjectStorage,
  DurableObjectStub,
  DurableObjectTransaction,
  DurableObjectsPlugin,
  ReadWriteMutex,
  ShadowStorage,
  _kRunWithGates,
  kAlarmExists
});
//# sourceMappingURL=index.js.map
