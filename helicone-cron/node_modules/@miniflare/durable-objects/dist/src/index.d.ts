/// <reference types="node" />

import { Awaitable } from '@miniflare/shared';
import { Context } from '@miniflare/shared';
import { MiniflareError } from '@miniflare/shared';
import { Mount } from '@miniflare/shared';
import { Plugin } from '@miniflare/shared';
import { PluginContext } from '@miniflare/shared';
import { Request } from '@miniflare/core';
import { RequestInfo } from '@miniflare/core';
import { RequestInit } from '@miniflare/core';
import { Response } from '@miniflare/core';
import { SetupResult } from '@miniflare/shared';
import { Storage } from '@miniflare/shared';
import { StorageFactory } from '@miniflare/shared';
import { StorageListOptions } from '@miniflare/shared';
import { StorageListResult } from '@miniflare/shared';
import { StoredKey } from '@miniflare/shared';
import { StoredValue } from '@miniflare/shared';

export declare const ALARM_KEY = "__MINIFLARE_ALARMS__";

export declare class AlarmStore {
    #private;
    setupStore(storage: StorageFactory, persist?: boolean | string): Promise<void>;
    setupAlarms(callback?: (objectKey: string) => Promise<void>): Promise<void>;
    buildBridge(objectKey: string): DurableObjectAlarmBridge;
    setAlarm(objectKey: string, scheduledTime: number | Date): Promise<void>;
    deleteAlarm(key: string): Promise<void>;
    flushAlarms(keys?: string[]): Promise<void>;
    dispose(): void;
}

export declare interface DurableObject {
    fetch(request: Request): Awaitable<Response>;
    alarm?(): Awaitable<void>;
}

export declare interface DurableObjectAlarm {
    scheduledTime: number;
    timeout?: NodeJS.Timeout;
}

export declare interface DurableObjectAlarmBridge {
    setAlarm: (scheduledTime: number | Date) => Promise<void>;
    deleteAlarm: () => Promise<void>;
}

export declare interface DurableObjectConstructor {
    new (state: DurableObjectState, env: Context): DurableObject;
}

export declare class DurableObjectError extends MiniflareError<DurableObjectErrorCode> {
}

export declare type DurableObjectErrorCode = "ERR_SCRIPT_NOT_FOUND" | "ERR_CLASS_NOT_FOUND" | "ERR_RESPONSE_TYPE" | "ERR_DESERIALIZATION" | "ERR_NO_HANDLER";

export declare type DurableObjectFactory = (id: DurableObjectId) => Promise<DurableObjectState>;

export declare interface DurableObjectGetAlarmOptions {
    allowConcurrency?: boolean;
}

export declare interface DurableObjectGetOptions {
    allowConcurrency?: boolean;
    noCache?: boolean;
}

export declare class DurableObjectId {
    #private;
    readonly name?: string | undefined;
    readonly [kObjectName]: string;
    constructor(objectName: string, hexId: string, name?: string | undefined);
    equals(other: DurableObjectId): boolean;
    toString(): string;
}

export declare interface DurableObjectListOptions extends DurableObjectGetOptions {
    start?: string;
    startAfter?: string;
    end?: string;
    prefix?: string;
    reverse?: boolean;
    limit?: number;
}

export declare class DurableObjectNamespace {
    #private;
    constructor(objectName: string, factory: DurableObjectFactory, ctx?: PluginContext);
    newUniqueId(_options?: NewUniqueIdOptions): DurableObjectId;
    idFromName(name: string): DurableObjectId;
    idFromString(hexId: string): DurableObjectId;
    get(id: DurableObjectId): DurableObjectStub;
}

export declare interface DurableObjectOperator {
    get<Value = unknown>(key: string, options?: DurableObjectGetOptions): Promise<Value | undefined>;
    get<Value = unknown>(keys: string[], options?: DurableObjectGetOptions): Promise<Map<string, Value>>;
    put<Value = unknown>(key: string, value: Value, options?: DurableObjectPutOptions): Promise<void>;
    put<Value = unknown>(entries: Record<string, Value>, options?: DurableObjectPutOptions): Promise<void>;
    delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
    delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
    list<Value = unknown>(options?: DurableObjectListOptions): Promise<Map<string, Value>>;
    getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise<void>;
    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
}

export declare interface DurableObjectPutOptions extends DurableObjectGetOptions {
    allowUnconfirmed?: boolean;
}

export declare interface DurableObjectSetAlarmOptions {
    allowConcurrency?: boolean;
    allowUnconfirmed?: boolean;
}

export declare type DurableObjectsObjectsOptions = Record<string, string | {
    className: string;
    scriptName?: string;
}>;

export declare interface DurableObjectsOptions {
    durableObjects?: DurableObjectsObjectsOptions;
    durableObjectsPersist?: boolean | string;
    durableObjectsAlarms?: boolean;
}

export declare class DurableObjectsPlugin extends Plugin<DurableObjectsOptions> implements DurableObjectsOptions {
    #private;
    durableObjects?: DurableObjectsObjectsOptions;
    durableObjectsPersist?: boolean | string;
    durableObjectsAlarms?: boolean;
    constructor(ctx: PluginContext, options?: DurableObjectsOptions);
    getStorage(storage: StorageFactory, id: DurableObjectId): DurableObjectStorage;
    getObject(storage: StorageFactory, id: DurableObjectId): Promise<DurableObjectState>;
    getNamespace(storage: StorageFactory, objectName: string): DurableObjectNamespace;
    setup(storageFactory: StorageFactory): Promise<SetupResult>;
    flushAlarms(storageFactory: StorageFactory, ids?: DurableObjectId[]): Promise<void>;
    beforeReload(): Promise<void>;
    reload(bindings: Context, moduleExports: Context, mounts: Map<string, Mount>): void;
    dispose(): Promise<void>;
}

export declare class DurableObjectState {
    #private;
    readonly id: DurableObjectId;
    readonly storage: DurableObjectStorage;
    [kInstance]?: DurableObject;
    constructor(id: DurableObjectId, storage: DurableObjectStorage);
    waitUntil(_promise: Promise<void>): void;
    blockConcurrencyWhile<T>(closure: () => Promise<T>): Promise<T>;
    /* Excluded from this release type: [_kRunWithGates] */
    [kFetch](request: Request): Promise<Response>;
    [kAlarm](): Promise<void>;
}

export declare class DurableObjectStorage implements DurableObjectOperator {
    #private;
    [kAlarmExists]: boolean;
    constructor(inner: Storage, alarmBridge?: DurableObjectAlarmBridge);
    transaction<T>(closure: (txn: DurableObjectTransaction) => Promise<T>): Promise<T>;
    get<Value = unknown>(key: string, options?: DurableObjectGetOptions): Promise<Value | undefined>;
    get<Value = unknown>(keys: string[], options?: DurableObjectGetOptions): Promise<Map<string, Value>>;
    put<Value = unknown>(key: string, value: Value, options?: DurableObjectPutOptions): Promise<void>;
    put<Value = unknown>(entries: Record<string, Value>, options?: DurableObjectPutOptions): Promise<void>;
    delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
    delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
    deleteAll(options?: DurableObjectPutOptions): Promise<void>;
    list<Value = unknown>(options?: DurableObjectListOptions): Promise<Map<string, Value>>;
    getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise<void>;
    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
}

export declare class DurableObjectStub {
    #private;
    readonly id: DurableObjectId;
    constructor(factory: DurableObjectFactory, id: DurableObjectId, ctx?: PluginContext);
    get name(): string | undefined;
    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;
}

export declare class DurableObjectTransaction implements DurableObjectOperator {
    #private;
    readonly [kInner]: ShadowStorage;
    readonly [kStartTxnCount]: number;
    [kRolledback]: boolean;
    [kCommitted]: boolean;
    readonly [kWriteSet]: Set<string>;
    readonly [kAlarmExists]: boolean;
    constructor(inner: Storage, startTxnCount: number, alarmExists: boolean);
    get<Value = unknown>(key: string, options?: DurableObjectGetOptions): Promise<Value | undefined>;
    get<Value = unknown>(keys: string[], options?: DurableObjectGetOptions): Promise<Map<string, Value>>;
    put<Value = unknown>(key: string, value: Value, options?: DurableObjectPutOptions): Promise<void>;
    put<Value = unknown>(entries: Record<string, Value>, options?: DurableObjectPutOptions): Promise<void>;
    delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
    delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
    deleteAll(): never;
    list<Value = unknown>(options?: DurableObjectListOptions): Promise<Map<string, Value>>;
    getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise<void>;
    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
    rollback(): void;
}

declare const kAlarm: unique symbol;

export declare const kAlarmExists: unique symbol;

declare const kCommitted: unique symbol;

declare const kFetch: unique symbol;

declare const kInner: unique symbol;

declare const kInstance: unique symbol;

declare const kObjectName: unique symbol;

declare const kRolledback: unique symbol;

/* Excluded from this release type: _kRunWithGates */

declare const kStartTxnCount: unique symbol;

declare const kWriteSet: unique symbol;

export declare interface NewUniqueIdOptions {
    jurisdiction?: string;
}

export declare class ReadWriteMutex {
    private readLockCount;
    private writeLocked;
    private readResolveQueue;
    private writeResolveQueue;
    private readLock;
    private writeLock;
    private unlock;
    runWithRead<T>(closure: () => Awaitable<T>): Promise<T>;
    runWithWrite<T>(closure: () => Awaitable<T>): Promise<T>;
}

export declare class ShadowStorage extends Storage {
    protected readonly inner: Storage;
    readonly readSet?: Set<string>;
    readonly copies: Map<string, StoredValue | undefined>;
    alarm?: number | null;
    constructor(inner: Storage, recordReads?: boolean);
    has(key: string): Promise<boolean>;
    hasMany(keys: string[]): Promise<number>;
    head(_key: string): Promise<undefined>;
    get(key: string): Promise<StoredValue | undefined>;
    getMany(keys: string[]): Promise<(StoredValue | undefined)[]>;
    getRange(_key: string): Promise<undefined>;
    put(key: string, value: StoredValue): void;
    delete(key: string): Promise<boolean>;
    deleteMany(keys: string[]): Promise<number>;
    list(options?: Omit<StorageListOptions, "cursor">): Promise<StorageListResult<StoredKey>>;
    getAlarm(): Promise<number | null>;
    setAlarm(scheduledTime: number | Date): Promise<void>;
    deleteAlarm(): Promise<void>;
}

export { }
