var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/r2/src/index.ts
__export(exports, {
  R2Bucket: () => R2Bucket,
  R2Object: () => R2Object,
  R2ObjectBody: () => R2ObjectBody,
  R2Plugin: () => R2Plugin,
  _valueToArray: () => _valueToArray,
  createHash: () => createHash,
  createVersion: () => createVersion,
  parseHttpMetadata: () => parseHttpMetadata,
  parseOnlyIf: () => parseOnlyIf,
  parseR2ObjectMetadata: () => parseR2ObjectMetadata,
  testR2Conditional: () => testR2Conditional
});

// packages/r2/src/bucket.ts
var import_buffer2 = __toModule(require("buffer"));
var import_consumers2 = __toModule(require("stream/consumers"));
var import_web2 = __toModule(require("stream/web"));
var import_util2 = __toModule(require("util"));
var import_shared2 = __toModule(require("@miniflare/shared"));
var import_undici2 = __toModule(require("undici"));

// packages/r2/src/r2Object.ts
var import_buffer = __toModule(require("buffer"));
var import_crypto = __toModule(require("crypto"));
var import_consumers = __toModule(require("stream/consumers"));
var import_web = __toModule(require("stream/web"));
var import_util = __toModule(require("util"));
var import_shared = __toModule(require("@miniflare/shared"));
var import_undici = __toModule(require("undici"));
var decoder = new import_util.TextDecoder();
function createHash(input) {
  return import_crypto.default.createHash("md5").update(input).digest("hex");
}
function createVersion() {
  const size = 32;
  return import_crypto.default.randomBytes(size).toString("base64").slice(0, size);
}
function parseR2ObjectMetadata(meta) {
  meta.uploaded = new Date(meta.uploaded);
  if (meta.httpMetadata.cacheExpiry) {
    meta.httpMetadata.cacheExpiry = new Date(meta.httpMetadata.cacheExpiry);
  }
}
function parseHttpMetadata(httpMetadata) {
  if (httpMetadata === void 0)
    return {};
  if (httpMetadata instanceof import_undici.Headers) {
    const cExpiry = httpMetadata.get("cache-expiry");
    return {
      contentType: httpMetadata.get("content-type") ?? void 0,
      contentLanguage: httpMetadata.get("content-language") ?? void 0,
      contentDisposition: httpMetadata.get("content-disposition") ?? void 0,
      contentEncoding: httpMetadata.get("content-encoding") ?? void 0,
      cacheControl: httpMetadata.get("cache-control") ?? void 0,
      cacheExpiry: cExpiry ? new Date(cExpiry) : void 0
    };
  } else {
    httpMetadata = { ...httpMetadata };
    const httpMetadataList = [
      "contentType",
      "contentLanguage",
      "contentDisposition",
      "contentEncoding",
      "cacheControl",
      "cacheExpiry"
    ];
    for (const key of Object.keys(httpMetadata)) {
      if (!httpMetadataList.includes(key)) {
        delete httpMetadata[key];
      }
    }
    return httpMetadata;
  }
}
function testR2Conditional(conditional, metadata) {
  const { etagMatches, etagDoesNotMatch, uploadedBefore, uploadedAfter } = conditional;
  if (metadata === void 0) {
    return etagMatches === void 0 && uploadedAfter === void 0;
  }
  const { etag, uploaded } = metadata;
  const ifMatch = etagMatches ? matchStrings(etagMatches, etag) : null;
  if (ifMatch === false)
    return false;
  const ifNoneMatch = etagDoesNotMatch ? !matchStrings(etagDoesNotMatch, etag) : null;
  if (ifNoneMatch === false)
    return false;
  if (ifMatch !== true && uploadedBefore !== void 0 && uploaded > uploadedBefore) {
    return false;
  }
  if (ifNoneMatch !== true && uploadedAfter !== void 0 && uploaded < uploadedAfter) {
    return false;
  }
  return true;
}
function matchStrings(a, b) {
  if (typeof a === "string")
    return a === b;
  else
    return a.includes(b);
}
function parseHeaderArray(input) {
  if (typeof input !== "string")
    return;
  if (!input.includes(","))
    return input;
  return input.split(",").map((x) => x.trim());
}
function parseOnlyIf(onlyIf) {
  if (onlyIf === void 0)
    return {};
  if (onlyIf instanceof import_undici.Headers) {
    onlyIf = {
      etagMatches: onlyIf.get("if-match") ?? void 0,
      etagDoesNotMatch: onlyIf.get("if-none-match") ?? void 0,
      uploadedBefore: onlyIf.get("if-unmodified-since") ?? void 0,
      uploadedAfter: onlyIf.get("if-modified-since") ?? void 0
    };
  }
  if (typeof onlyIf.etagMatches === "string") {
    onlyIf.etagMatches = parseHeaderArray(onlyIf.etagMatches);
  }
  if (typeof onlyIf.etagDoesNotMatch === "string") {
    onlyIf.etagDoesNotMatch = parseHeaderArray(onlyIf.etagDoesNotMatch);
  }
  if (typeof onlyIf.uploadedBefore === "string") {
    onlyIf.uploadedBefore = new Date(onlyIf.uploadedBefore);
  }
  if (typeof onlyIf.uploadedAfter === "string") {
    onlyIf.uploadedAfter = new Date(onlyIf.uploadedAfter);
  }
  return onlyIf;
}
var R2Object = class {
  key;
  version;
  size;
  etag;
  httpEtag;
  uploaded;
  httpMetadata;
  customMetadata;
  range;
  constructor(metadata) {
    this.key = metadata.key;
    this.version = metadata.version;
    this.size = metadata.size;
    this.etag = metadata.etag;
    this.httpEtag = metadata.httpEtag;
    this.uploaded = metadata.uploaded;
    this.httpMetadata = metadata.httpMetadata;
    this.customMetadata = metadata.customMetadata;
    this.range = metadata.range;
  }
  writeHttpMetadata(headers) {
    for (const [key, value] of Object.entries(this.httpMetadata)) {
      const camelToDash = key.replace(/([A-Z])/g, "-$1").toLowerCase();
      headers.set(camelToDash, value);
    }
  }
};
var R2ObjectBody = class extends R2Object {
  body;
  bodyUsed = false;
  constructor(metadata, value) {
    super(metadata);
    const setBodyUsed = () => {
      this.bodyUsed = true;
    };
    this.body = new import_web.ReadableStream({
      type: "bytes",
      async pull(controller) {
        await (0, import_shared.waitForOpenInputGate)();
        if (value.byteLength)
          controller.enqueue(value);
        controller.close();
        controller.byobRequest?.respond(0);
        setBodyUsed();
      }
    });
  }
  async arrayBuffer() {
    if (this.bodyUsed)
      throw new TypeError("Body already used.");
    return (0, import_consumers.arrayBuffer)(this.body);
  }
  async text() {
    return decoder.decode(await this.arrayBuffer());
  }
  async json() {
    return JSON.parse(await this.text());
  }
  async blob() {
    const ab = await this.arrayBuffer();
    return new import_buffer.Blob([new Uint8Array(ab)]);
  }
};

// packages/r2/src/bucket.ts
var MAX_LIST_KEYS = 1e3;
var MAX_KEY_SIZE = 1024;
var MAX_VALUE_SIZE = 5 * 1e3 * 1e3 * 1e3 - 5 * 1e3 * 1e3;
var UNPAIRED_SURROGATE_PAIR_REGEX = /^(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])$/;
var encoder = new import_util2.TextEncoder();
function throwR2Error(method, status, message) {
  throw new Error(`R2 ${method} failed: (${status}) ${message}`);
}
function validateKey(method, key) {
  const keyLength = encoder.encode(key).byteLength;
  if (UNPAIRED_SURROGATE_PAIR_REGEX.test(key)) {
    throwR2Error(method, 400, "Key contains an illegal unicode value(s).");
  }
  if (keyLength >= MAX_KEY_SIZE) {
    throwR2Error(method, 414, `UTF-8 encoded length of ${keyLength} exceeds key length limit of ${MAX_KEY_SIZE}.`);
  }
}
function validateOnlyIf(onlyIf, method) {
  if (onlyIf instanceof import_undici2.Headers)
    return;
  if (typeof onlyIf !== "object") {
    throwR2Error(method, 400, "onlyIf must be an object, a Headers instance, or undefined.");
  }
  const { etagMatches, etagDoesNotMatch, uploadedBefore, uploadedAfter } = onlyIf;
  if (etagMatches !== void 0 && !(typeof etagMatches === "string" || Array.isArray(etagMatches))) {
    throwR2Error(method, 400, "etagMatches must be a string.");
  }
  if (etagDoesNotMatch !== void 0 && !(typeof etagDoesNotMatch === "string" || Array.isArray(etagDoesNotMatch))) {
    throwR2Error(method, 400, "etagDoesNotMatch must be a string.");
  }
  if (uploadedBefore !== void 0 && !(uploadedBefore instanceof Date)) {
    throwR2Error(method, 400, "uploadedBefore must be a Date.");
  }
  if (uploadedAfter !== void 0 && !(uploadedAfter instanceof Date)) {
    throwR2Error(method, 400, "uploadedAfter must be a Date.");
  }
}
function validateGetOptions(options) {
  const { onlyIf = {}, range = {} } = options;
  validateOnlyIf(onlyIf, "GET");
  if (typeof range !== "object") {
    throwR2Error("GET", 400, "range must either be an object or undefined.");
  }
  const { offset, length, suffix } = range;
  if (offset !== void 0) {
    if (typeof offset !== "number") {
      throwR2Error("GET", 400, "offset must either be a number or undefined.");
    }
    if (offset < 0) {
      throwR2Error("GET", 400, "Invalid range. Starting offset must be greater than or equal to 0.");
    }
  }
  if (length !== void 0 && typeof length !== "number") {
    throwR2Error("GET", 400, "length must either be a number or undefined.");
  }
  if (suffix !== void 0 && typeof suffix !== "number") {
    throwR2Error("GET", 400, "suffix must either be a number or undefined.");
  }
}
function validateHttpMetadata(httpMetadata) {
  if (httpMetadata === void 0 || httpMetadata instanceof import_undici2.Headers)
    return;
  if (typeof httpMetadata !== "object") {
    throwR2Error("PUT", 400, "httpMetadata must be an object or undefined.");
  }
  for (const [key, value] of Object.entries(httpMetadata)) {
    if (key === "cacheExpiry") {
      if (!(value instanceof Date) && value !== void 0) {
        throwR2Error("PUT", 400, "cacheExpiry's value must be a Date or undefined.");
      }
    } else {
      if (typeof value !== "string" && value !== void 0) {
        throwR2Error("PUT", 400, `${key}'s value must be a string or undefined.`);
      }
    }
  }
}
function validatePutOptions(options) {
  const { onlyIf = {}, httpMetadata, customMetadata, md5 } = options;
  validateOnlyIf(onlyIf, "PUT");
  validateHttpMetadata(httpMetadata);
  if (customMetadata !== void 0) {
    if (typeof customMetadata !== "object") {
      throwR2Error("PUT", 400, "customMetadata must be an object or undefined.");
    }
    for (const value of Object.values(customMetadata)) {
      if (typeof value !== "string") {
        throwR2Error("PUT", 400, "customMetadata values must be strings.");
      }
    }
  }
  if (md5 !== void 0 && !(md5 instanceof ArrayBuffer) && typeof md5 !== "string") {
    throwR2Error("PUT", 400, "md5 must be a string, ArrayBuffer, or undefined.");
  }
}
function validateListOptions(options) {
  const { limit, prefix, cursor, delimiter, startAfter, include } = options;
  if (limit !== void 0) {
    if (typeof limit !== "number") {
      throwR2Error("LIST", 400, "limit must be a number or undefined.");
    }
    if (limit < 1 || limit > MAX_LIST_KEYS) {
      throwR2Error("LIST", 400, `MaxKeys params must be positive integer <= 1000.`);
    }
  }
  if (prefix !== void 0 && typeof prefix !== "string") {
    throwR2Error("LIST", 400, "prefix must be a string or undefined.");
  }
  if (cursor !== void 0 && typeof cursor !== "string") {
    throwR2Error("LIST", 400, "cursor must be a string or undefined.");
  }
  if (delimiter !== void 0 && typeof delimiter !== "string") {
    throwR2Error("LIST", 400, "delimiter must be a string or undefined.");
  }
  if (startAfter !== void 0 && typeof startAfter !== "string") {
    throwR2Error("LIST", 400, "startAfter must be a string or undefined.");
  }
  if (include !== void 0) {
    if (!Array.isArray(include)) {
      throwR2Error("LIST", 400, "include must be an array or undefined.");
    }
    for (const value of include) {
      if (value !== "httpMetadata" && value !== "customMetadata") {
        throwR2Error("LIST", 400, "include values must be httpMetadata and/or customMetadata strings.");
      }
    }
  }
}
async function _valueToArray(value) {
  if (typeof value === "string") {
    return encoder.encode(value);
  } else if (value instanceof import_web2.ReadableStream) {
    return new Uint8Array(await (0, import_consumers2.arrayBuffer)(value));
  } else if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  } else if (ArrayBuffer.isView(value)) {
    return (0, import_shared2.viewToArray)(value);
  } else if (value === null) {
    return new Uint8Array();
  } else if (value instanceof import_buffer2.Blob) {
    return new Uint8Array(await value.arrayBuffer());
  } else {
    throw new TypeError("R2 put() accepts only nulls, strings, Blobs, ArrayBuffers, ArrayBufferViews, and ReadableStreams as values.");
  }
}
var R2Bucket = class {
  #storage;
  #blockGlobalAsyncIO;
  constructor(storage, { blockGlobalAsyncIO = false } = {}) {
    this.#storage = storage;
    this.#blockGlobalAsyncIO = blockGlobalAsyncIO;
  }
  #prepareCtx(method, key) {
    if (this.#blockGlobalAsyncIO)
      (0, import_shared2.assertInRequest)();
    const ctx = (0, import_shared2.getRequestContext)();
    ctx?.incrementInternalSubrequests();
    if (method !== "LIST" && typeof key !== "string") {
      throw new TypeError(`Failed to execute '${method.toLowerCase()}' on 'R2Bucket': parameter 1 is not of type 'string'.`);
    }
    return ctx;
  }
  async #head(key, ctx) {
    if (ctx === void 0)
      ctx = this.#prepareCtx("HEAD", key);
    validateKey("HEAD", key);
    const stored = await this.#storage.head(key);
    await (0, import_shared2.waitForOpenInputGate)();
    ctx?.advanceCurrentTime();
    if (stored?.metadata === void 0)
      return null;
    const { metadata } = stored;
    parseR2ObjectMetadata(metadata);
    return new R2Object(metadata);
  }
  async head(key) {
    return this.#head(key);
  }
  async get(key, options) {
    const ctx = this.#prepareCtx("GET", key);
    options = options ?? {};
    const { range = {} } = options;
    validateKey("GET", key);
    validateGetOptions(options);
    const onlyIf = parseOnlyIf(options.onlyIf);
    const meta = await this.#head(key, ctx);
    if (meta === null)
      return null;
    if (!testR2Conditional(onlyIf, meta) || meta?.size === 0) {
      return new R2Object(meta);
    }
    let stored;
    try {
      stored = await this.#storage.getRange(key, range);
    } catch {
      throwR2Error("GET", 400, "The requested range is not satisfiable.");
    }
    await (0, import_shared2.waitForOpenInputGate)();
    ctx?.advanceCurrentTime();
    if (stored?.metadata === void 0)
      return null;
    const { value, metadata } = stored;
    parseR2ObjectMetadata(metadata);
    if ("range" in stored && stored.range !== void 0) {
      metadata.range = stored.range;
    }
    return new R2ObjectBody(metadata, value);
  }
  async put(key, value, options = {}) {
    const ctx = this.#prepareCtx("PUT", key);
    validateKey("PUT", key);
    validatePutOptions(options);
    const { customMetadata = {} } = options;
    let { md5, onlyIf, httpMetadata } = options;
    onlyIf = parseOnlyIf(onlyIf);
    httpMetadata = parseHttpMetadata(httpMetadata);
    const meta = await this.#head(key, ctx) ?? void 0;
    if (!testR2Conditional(onlyIf, meta))
      return null;
    const toStore = await _valueToArray(value);
    if (toStore.byteLength > MAX_VALUE_SIZE) {
      throwR2Error("PUT", 400, `Value length of ${toStore.byteLength} exceeds limit of ${MAX_VALUE_SIZE}.`);
    }
    const md5Hash = createHash(toStore);
    if (md5 !== void 0) {
      if (md5 instanceof ArrayBuffer) {
        md5 = Buffer.from(new Uint8Array(md5)).toString("hex");
      }
      if (md5 !== md5Hash) {
        throwR2Error("PUT", 400, "The Content-MD5 you specified did not match what we received.");
      }
    }
    const metadata = {
      key,
      size: toStore.byteLength,
      etag: md5Hash,
      version: createVersion(),
      httpEtag: `"${md5Hash}"`,
      uploaded: new Date(),
      httpMetadata,
      customMetadata
    };
    await (0, import_shared2.waitForOpenOutputGate)();
    await this.#storage.put(key, {
      value: toStore,
      metadata
    });
    await (0, import_shared2.waitForOpenInputGate)();
    ctx?.advanceCurrentTime();
    return new R2Object(metadata);
  }
  async delete(key) {
    const ctx = this.#prepareCtx("DELETE", key);
    validateKey("DELETE", key);
    await (0, import_shared2.waitForOpenOutputGate)();
    await this.#storage.delete(key);
    await (0, import_shared2.waitForOpenInputGate)();
    ctx?.advanceCurrentTime();
  }
  async list(listOptions = {}) {
    const ctx = this.#prepareCtx("LIST");
    const delimitedPrefixes = new Set();
    validateListOptions(listOptions);
    const { prefix = "", include = [], startAfter, cursor = "" } = listOptions;
    let { delimiter, limit = MAX_LIST_KEYS } = listOptions;
    if (delimiter === "")
      delimiter = void 0;
    if (include.length > 0)
      limit = Math.min(limit, 100);
    if (startAfter !== void 0)
      limit++;
    const res = await this.#storage.list({
      prefix,
      limit,
      cursor,
      start: startAfter,
      delimiter
    });
    for (const dP of res.delimitedPrefixes ?? [])
      delimitedPrefixes.add(dP);
    const objects = res.keys.map((k) => k.metadata).filter((metadata) => metadata !== void 0).map((metadata) => {
      if (!include.includes("httpMetadata"))
        metadata.httpMetadata = {};
      if (!include.includes("customMetadata"))
        metadata.customMetadata = {};
      parseR2ObjectMetadata(metadata);
      return new R2Object(metadata);
    });
    if (startAfter !== void 0) {
      if (objects[0].key === startAfter) {
        objects.splice(0, 1);
      } else if (objects.length > limit - 1) {
        objects.splice(0, limit - 1);
      }
    }
    await (0, import_shared2.waitForOpenInputGate)();
    ctx?.advanceCurrentTime();
    const cursorLength = res.cursor.length > 0;
    return {
      objects,
      truncated: cursorLength,
      cursor: cursorLength ? res.cursor : void 0,
      delimitedPrefixes: [...delimitedPrefixes]
    };
  }
};

// packages/r2/src/plugin.ts
var import_shared3 = __toModule(require("@miniflare/shared"));
var R2Plugin = class extends import_shared3.Plugin {
  r2Buckets;
  r2Persist;
  #persist;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
    this.#persist = (0, import_shared3.resolveStoragePersist)(ctx.rootPath, this.r2Persist);
  }
  getBucket(storage, bucket, blockGlobalAsyncIO = false) {
    return new R2Bucket(storage.storage(bucket, this.#persist), {
      blockGlobalAsyncIO
    });
  }
  setup(storageFactory) {
    const blockGlobalAsyncIO = !this.ctx.globalAsyncIO;
    const bindings = {};
    for (const bucket of this.r2Buckets ?? []) {
      bindings[bucket] = this.getBucket(storageFactory, bucket, blockGlobalAsyncIO);
    }
    return { bindings };
  }
};
__decorateClass([
  (0, import_shared3.Option)({
    type: import_shared3.OptionType.ARRAY,
    name: "r2",
    alias: "r",
    description: "R2 bucket to bind",
    logName: "R2 Buckets",
    fromWrangler: ({ r2_buckets }) => r2_buckets?.map(({ binding }) => binding)
  })
], R2Plugin.prototype, "r2Buckets", 2);
__decorateClass([
  (0, import_shared3.Option)({
    type: import_shared3.OptionType.BOOLEAN_STRING,
    description: "Persist R2 data (to optional path)",
    logName: "R2 Persistence",
    fromWrangler: ({ miniflare }) => miniflare?.r2_persist
  })
], R2Plugin.prototype, "r2Persist", 2);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  R2Bucket,
  R2Object,
  R2ObjectBody,
  R2Plugin,
  _valueToArray,
  createHash,
  createVersion,
  parseHttpMetadata,
  parseOnlyIf,
  parseR2ObjectMetadata,
  testR2Conditional
});
//# sourceMappingURL=index.js.map
