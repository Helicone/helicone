/**
 *
 * DO NOT EDIT THIS FILE UNLESS IT IS IN /costs/src/index.ts
 */

import { ModelRow } from "./interfaces/Cost";
import { allCosts, defaultProvider, providers } from "./providers/mappings";

export function costOf({
  model,
  provider,
}: {
  model: string;
  provider: string;
}) {
  const modelLower = model?.toLowerCase();

  if (!modelLower) {
    return null;
  }

  const providerCost = providers.find((p) => {
    return (
      p.provider === provider ||
      (p.pattern && p.pattern.test(provider) ? true : false)
    );
  });

  if (!providerCost || !providerCost.costs) {
    return null;
  }

  // We need to concat allCosts because we need to check the provider costs first and if it is not founder then fall back to make the best guess.
  // This is because we did not backfill the provider on db yet, and we do not plan to
  // This is really for legacy
  // TODO: after 07/2024 we can probably remove this
  const costs = providerCost.costs.concat(allCosts);

  const cost = costs.find((cost) => {
    const valueLower = cost.model.value.toLowerCase();
    if (cost.model.operator === "equals") {
      return valueLower === modelLower;
    } else if (cost.model.operator === "startsWith") {
      return modelLower.startsWith(valueLower);
    } else if (cost.model.operator === "includes") {
      return modelLower.includes(valueLower);
    }
  });

  return cost?.cost;
}

export function costOfPrompt({
  provider,
  model,
  promptTokens,
  promptCacheWriteTokens,
  promptCacheReadTokens,
  promptAudioTokens,
  completionTokens,
  completionAudioTokens,
  images = 1,
  perCall = 1,
}: {
  provider: string;
  model: string;
  promptTokens: number;
  promptCacheWriteTokens: number;
  promptCacheReadTokens: number;
  promptAudioTokens: number;
  completionTokens: number;
  completionAudioTokens: number;
  images?: number;
  perCall?: number;
}) {
  const cost = costOf({ model, provider });
  if (!cost) {
    return null;
  }

  let totalCost = 0;

  // Add cost for regular prompt tokens (these are the fresh, uncached tokens)
  totalCost += promptTokens * cost.prompt_token;

  // Add cost for cache write tokens if applicable
  if (cost.prompt_cache_write_token && promptCacheWriteTokens > 0) {
    totalCost += promptCacheWriteTokens * cost.prompt_cache_write_token;
  } else if (promptCacheWriteTokens > 0) {
    totalCost += promptCacheWriteTokens * cost.prompt_token;
  }

  // Add cost for cache read tokens if applicable
  if (cost.prompt_cache_read_token && promptCacheReadTokens > 0) {
    totalCost += promptCacheReadTokens * cost.prompt_cache_read_token;
  } else if (promptCacheReadTokens > 0) {
    totalCost += promptCacheReadTokens * cost.prompt_token;
  }

  // Add cost for prompt audio tokens if applicable
  if (cost.prompt_audio_token && promptAudioTokens > 0) {
    totalCost += promptAudioTokens * cost.prompt_audio_token;
  } else if (promptAudioTokens > 0) {
    totalCost += promptAudioTokens * cost.prompt_token;
  }

  // Add cost for completion tokens
  totalCost += completionTokens * cost.completion_token;

  // Add cost for completion audio tokens if applicable
  if (cost.completion_audio_token && completionAudioTokens > 0) {
    totalCost += completionAudioTokens * cost.completion_audio_token;
  } else if (completionAudioTokens > 0) {
    totalCost += completionAudioTokens * cost.completion_token;
  }

  // Add cost for images and per-call fees
  const imageCost = images * (cost.per_image ?? 0);
  const perCallCost = perCall * (cost.per_call ?? 0);
  totalCost += imageCost + perCallCost;

  return totalCost;
}

function caseForCost(costs: ModelRow[], table: string, multiple: number) {
  return `
  CASE
  ${costs
    .map((cost) => {
      const costPerMultiple = {
        prompt: Math.round(cost.cost.prompt_token * multiple),
        completion: Math.round(cost.cost.completion_token * multiple),
        prompt_audio: Math.round(
          (cost.cost.prompt_audio_token ?? cost.cost.prompt_token) * multiple
        ),
        completion_audio: Math.round(
          (cost.cost.completion_audio_token ?? cost.cost.completion_token) *
            multiple
        ),
        prompt_cache_write: Math.round(
          (cost.cost.prompt_cache_write_token ?? cost.cost.prompt_token) *
            multiple
        ),
        prompt_cache_read: Math.round(
          (cost.cost.prompt_cache_read_token ?? cost.cost.prompt_token) *
            multiple
        ),
        image: Math.round((cost.cost.per_image ?? 0) * multiple),
        per_call: Math.round((cost.cost.per_call ?? 0) * multiple),
      };

      const costParts = [];
      if (costPerMultiple.prompt > 0) {
        costParts.push(`${costPerMultiple.prompt} * ${table}.prompt_tokens`);
      }
      if (costPerMultiple.completion > 0) {
        costParts.push(
          `${costPerMultiple.completion} * ${table}.completion_tokens`
        );
      }
      if (costPerMultiple.prompt_audio > 0) {
        costParts.push(
          `${costPerMultiple.prompt_audio} * ${table}.prompt_audio_tokens`
        );
      }
      if (costPerMultiple.completion_audio > 0) {
        costParts.push(
          `${costPerMultiple.completion_audio} * ${table}.completion_audio_tokens`
        );
      }
      if (costPerMultiple.prompt_cache_write > 0) {
        costParts.push(
          `${costPerMultiple.prompt_cache_write} * ${table}.prompt_cache_write_tokens`
        );
      }
      if (costPerMultiple.prompt_cache_read > 0) {
        costParts.push(
          `${costPerMultiple.prompt_cache_read} * ${table}.prompt_cache_read_tokens`
        );
      }
      if (costPerMultiple.image > 0) {
        costParts.push(`${costPerMultiple.image}`); // Assuming image cost is per image, not per token
      }
      if (costPerMultiple.per_call > 0) {
        costParts.push(`${costPerMultiple.per_call}`); // Assuming per_call cost is per call
      }

      if (costParts.length > 0) {
        const costString = costParts.join(" + ");
        if (cost.model.operator === "equals") {
          return `WHEN (${table}.model ILIKE '${cost.model.value}') THEN ${costString}`;
        } else if (cost.model.operator === "startsWith") {
          return `WHEN (${table}.model LIKE '${cost.model.value}%') THEN ${costString}`;
        } else if (cost.model.operator === "includes") {
          return `WHEN (${table}.model ILIKE '%${cost.model.value}%') THEN ${costString}`;
        } else {
          throw new Error("Unknown operator");
        }
      } else {
        return ``; // Return empty string if no costs apply for this model
      }
    })
    .join("\n")}
  ELSE 0
END
`;
}
export const COST_MULTIPLE = 1_000_000_000;

export function clickhousePriceCalcNonAggregated(table: string) {
  // This is so that we don't need to do any floating point math in the database
  // and we can just divide by 1_000_000 to get the cost in dollars

  const providersWithCosts = providers.filter(
    (p) => p.costs && defaultProvider.provider !== p.provider
  );
  if (!defaultProvider.costs) {
    throw new Error("Default provider does not have costs");
  }
  return `
(
  CASE
    ${providersWithCosts
      .map((provider) => {
        if (!provider.costs) {
          throw new Error("Provider does not have costs");
        }
        return `    WHEN (${table}.provider = '${provider.provider}') 
      THEN (${caseForCost(provider.costs, table, COST_MULTIPLE)})`;
      })
      .join("\n")}
    ELSE (${caseForCost(defaultProvider.costs, table, COST_MULTIPLE)})
  END
) / ${COST_MULTIPLE}
`;
}

export function clickhousePriceCalc(table: string) {
  // This is so that we don't need to do any floating point math in the database
  // and we can just divide by 1_000_000 to get the cost in dollars

  const providersWithCosts = providers.filter(
    (p) => p.costs && defaultProvider.provider !== p.provider
  );
  if (!defaultProvider.costs) {
    throw new Error("Default provider does not have costs");
  }
  return `
sum(
  CASE
  ${providersWithCosts
    .map((provider) => {
      if (!provider.costs) {
        throw new Error("Provider does not have costs");
      }

      return `WHEN (${table}.provider = '${
        provider.provider
      }') THEN (${caseForCost(provider.costs, table, COST_MULTIPLE)})`;
    })
    .join("\n")}
    ELSE ${caseForCost(defaultProvider.costs, table, COST_MULTIPLE)}
  END
  ) / ${COST_MULTIPLE}
`;
}
